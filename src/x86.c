enum { EAX=0, ECX=1, EDX=2, EBX=3, ESI=6, EDI=7 };
#include "c.h"
#define NODEPTR_TYPE Node
#define OP_LABEL(p) ((p)->op)
#define LEFT_CHILD(p) ((p)->kids[0])
#define RIGHT_CHILD(p) ((p)->kids[1])
#define STATE_LABEL(p) ((p)->x.state)
static void address     ARGS((Symbol, Symbol, int));
static void blkfetch    ARGS((int, int, int, int));
static void blkloop     ARGS((int, int, int, int, int, int[]));
static void blkstore    ARGS((int, int, int, int));
static void defaddress  ARGS((Symbol));
static void defconst    ARGS((int, Value));
static void defstring   ARGS((int, char *));
static void defsymbol   ARGS((Symbol));
static void doarg       ARGS((Node));
static void emit2       ARGS((Node));
static void export      ARGS((Symbol));
static void clobber     ARGS((Node));
static void function    ARGS((Symbol, Symbol [], Symbol [], int));
static void global      ARGS((Symbol));
static void import      ARGS((Symbol));
static void local       ARGS((Symbol));
static void progbeg     ARGS((int, char **));
static void progend     ARGS((void));
static void segment     ARGS((int));
static void space       ARGS((int));
static void target      ARGS((Node));
static int ckstack ARGS((Node, int));
static int memop ARGS((Node));
static int sametree ARGS((Node, Node));
static Symbol charreg[32], shortreg[32], intreg[32];
static Symbol fltreg[32];

static int cseg;

static Symbol quo, rem;

/*
generated at Fri Oct 18 20:46:05 1996
by $Id$
*/
static void _kids ARGS((NODEPTR_TYPE, int, NODEPTR_TYPE[]));
static void _label ARGS((NODEPTR_TYPE));
static int _rule ARGS((void*, int));

#define _stmt_NT 1
#define _reg_NT 2
#define _con_NT 3
#define _acon_NT 4
#define _base_NT 5
#define _index_NT 6
#define _con1_NT 7
#define _con2_NT 8
#define _con3_NT 9
#define _addr_NT 10
#define _mem_NT 11
#define _rc_NT 12
#define _mr_NT 13
#define _mrc0_NT 14
#define _mrc1_NT 15
#define _mrc3_NT 16
#define _rc5_NT 17
#define _memf_NT 18
#define _flt_NT 19
#define _addrj_NT 20
#define _cmpf_NT 21

static char *_ntname[] = {
	0,
	"stmt",
	"reg",
	"con",
	"acon",
	"base",
	"index",
	"con1",
	"con2",
	"con3",
	"addr",
	"mem",
	"rc",
	"mr",
	"mrc0",
	"mrc1",
	"mrc3",
	"rc5",
	"memf",
	"flt",
	"addrj",
	"cmpf",
	0
};

struct _state {
	short cost[22];
	struct {
		unsigned int _stmt:7;
		unsigned int _reg:7;
		unsigned int _con:3;
		unsigned int _acon:2;
		unsigned int _base:3;
		unsigned int _index:3;
		unsigned int _con1:2;
		unsigned int _con2:2;
		unsigned int _con3:2;
		unsigned int _addr:3;
		unsigned int _mem:3;
		unsigned int _rc:2;
		unsigned int _mr:2;
		unsigned int _mrc0:2;
		unsigned int _mrc1:2;
		unsigned int _mrc3:2;
		unsigned int _rc5:2;
		unsigned int _memf:2;
		unsigned int _flt:2;
		unsigned int _addrj:2;
		unsigned int _cmpf:2;
	} rule;
};

static short _nts_0[] = { 0 };
static short _nts_1[] = { _reg_NT, 0 };
static short _nts_2[] = { _con_NT, 0 };
static short _nts_3[] = { _reg_NT, _acon_NT, 0 };
static short _nts_4[] = { _reg_NT, _con1_NT, 0 };
static short _nts_5[] = { _reg_NT, _con2_NT, 0 };
static short _nts_6[] = { _reg_NT, _con3_NT, 0 };
static short _nts_7[] = { _base_NT, 0 };
static short _nts_8[] = { _index_NT, _base_NT, 0 };
static short _nts_9[] = { _index_NT, 0 };
static short _nts_10[] = { _addr_NT, 0 };
static short _nts_11[] = { _mem_NT, 0 };
static short _nts_12[] = { _rc_NT, 0 };
static short _nts_13[] = { _mrc0_NT, 0 };
static short _nts_14[] = { _reg_NT, _mrc1_NT, 0 };
static short _nts_15[] = { _addr_NT, _mem_NT, _con1_NT, 0 };
static short _nts_16[] = { _addr_NT, _mem_NT, _rc_NT, 0 };
static short _nts_17[] = { _addr_NT, _mem_NT, 0 };
static short _nts_18[] = { _reg_NT, _rc5_NT, 0 };
static short _nts_19[] = { _addr_NT, _mem_NT, _rc5_NT, 0 };
static short _nts_20[] = { _reg_NT, _mrc3_NT, 0 };
static short _nts_21[] = { _con_NT, _mr_NT, 0 };
static short _nts_22[] = { _reg_NT, _mr_NT, 0 };
static short _nts_23[] = { _reg_NT, _reg_NT, 0 };
static short _nts_24[] = { _addr_NT, _rc_NT, 0 };
static short _nts_25[] = { _mrc3_NT, 0 };
static short _nts_26[] = { _memf_NT, 0 };
static short _nts_27[] = { _addr_NT, _reg_NT, 0 };
static short _nts_28[] = { _reg_NT, _flt_NT, 0 };
static short _nts_29[] = { _addrj_NT, 0 };
static short _nts_30[] = { _mem_NT, _rc_NT, 0 };
static short _nts_31[] = { _cmpf_NT, _reg_NT, 0 };

static short *_nts[] = {
	0,	/* 0 */
	_nts_0,	/* 1 */
	_nts_0,	/* 2 */
	_nts_0,	/* 3 */
	_nts_0,	/* 4 */
	_nts_0,	/* 5 */
	_nts_0,	/* 6 */
	_nts_1,	/* 7 */
	_nts_1,	/* 8 */
	_nts_1,	/* 9 */
	_nts_1,	/* 10 */
	_nts_1,	/* 11 */
	_nts_1,	/* 12 */
	_nts_0,	/* 13 */
	_nts_0,	/* 14 */
	_nts_0,	/* 15 */
	_nts_0,	/* 16 */
	_nts_0,	/* 17 */
	_nts_1,	/* 18 */
	_nts_1,	/* 19 */
	_nts_1,	/* 20 */
	_nts_1,	/* 21 */
	_nts_1,	/* 22 */
	_nts_0,	/* 23 */
	_nts_2,	/* 24 */
	_nts_0,	/* 25 */
	_nts_1,	/* 26 */
	_nts_3,	/* 27 */
	_nts_3,	/* 28 */
	_nts_3,	/* 29 */
	_nts_0,	/* 30 */
	_nts_0,	/* 31 */
	_nts_1,	/* 32 */
	_nts_4,	/* 33 */
	_nts_5,	/* 34 */
	_nts_6,	/* 35 */
	_nts_0,	/* 36 */
	_nts_0,	/* 37 */
	_nts_0,	/* 38 */
	_nts_0,	/* 39 */
	_nts_0,	/* 40 */
	_nts_0,	/* 41 */
	_nts_4,	/* 42 */
	_nts_5,	/* 43 */
	_nts_6,	/* 44 */
	_nts_7,	/* 45 */
	_nts_8,	/* 46 */
	_nts_8,	/* 47 */
	_nts_8,	/* 48 */
	_nts_9,	/* 49 */
	_nts_10,	/* 50 */
	_nts_10,	/* 51 */
	_nts_10,	/* 52 */
	_nts_10,	/* 53 */
	_nts_1,	/* 54 */
	_nts_2,	/* 55 */
	_nts_1,	/* 56 */
	_nts_11,	/* 57 */
	_nts_11,	/* 58 */
	_nts_12,	/* 59 */
	_nts_11,	/* 60 */
	_nts_12,	/* 61 */
	_nts_11,	/* 62 */
	_nts_12,	/* 63 */
	_nts_10,	/* 64 */
	_nts_13,	/* 65 */
	_nts_1,	/* 66 */
	_nts_1,	/* 67 */
	_nts_1,	/* 68 */
	_nts_1,	/* 69 */
	_nts_1,	/* 70 */
	_nts_14,	/* 71 */
	_nts_14,	/* 72 */
	_nts_14,	/* 73 */
	_nts_14,	/* 74 */
	_nts_14,	/* 75 */
	_nts_14,	/* 76 */
	_nts_14,	/* 77 */
	_nts_14,	/* 78 */
	_nts_14,	/* 79 */
	_nts_15,	/* 80 */
	_nts_15,	/* 81 */
	_nts_15,	/* 82 */
	_nts_15,	/* 83 */
	_nts_15,	/* 84 */
	_nts_15,	/* 85 */
	_nts_16,	/* 86 */
	_nts_16,	/* 87 */
	_nts_16,	/* 88 */
	_nts_16,	/* 89 */
	_nts_16,	/* 90 */
	_nts_16,	/* 91 */
	_nts_16,	/* 92 */
	_nts_1,	/* 93 */
	_nts_1,	/* 94 */
	_nts_17,	/* 95 */
	_nts_17,	/* 96 */
	_nts_18,	/* 97 */
	_nts_18,	/* 98 */
	_nts_18,	/* 99 */
	_nts_18,	/* 100 */
	_nts_19,	/* 101 */
	_nts_19,	/* 102 */
	_nts_19,	/* 103 */
	_nts_19,	/* 104 */
	_nts_0,	/* 105 */
	_nts_1,	/* 106 */
	_nts_20,	/* 107 */
	_nts_21,	/* 108 */
	_nts_22,	/* 109 */
	_nts_23,	/* 110 */
	_nts_23,	/* 111 */
	_nts_23,	/* 112 */
	_nts_23,	/* 113 */
	_nts_1,	/* 114 */
	_nts_1,	/* 115 */
	_nts_1,	/* 116 */
	_nts_1,	/* 117 */
	_nts_10,	/* 118 */
	_nts_10,	/* 119 */
	_nts_10,	/* 120 */
	_nts_10,	/* 121 */
	_nts_1,	/* 122 */
	_nts_1,	/* 123 */
	_nts_1,	/* 124 */
	_nts_1,	/* 125 */
	_nts_1,	/* 126 */
	_nts_1,	/* 127 */
	_nts_1,	/* 128 */
	_nts_1,	/* 129 */
	_nts_24,	/* 130 */
	_nts_24,	/* 131 */
	_nts_24,	/* 132 */
	_nts_24,	/* 133 */
	_nts_25,	/* 134 */
	_nts_25,	/* 135 */
	_nts_23,	/* 136 */
	_nts_1,	/* 137 */
	_nts_10,	/* 138 */
	_nts_10,	/* 139 */
	_nts_10,	/* 140 */
	_nts_26,	/* 141 */
	_nts_27,	/* 142 */
	_nts_27,	/* 143 */
	_nts_27,	/* 144 */
	_nts_1,	/* 145 */
	_nts_1,	/* 146 */
	_nts_1,	/* 147 */
	_nts_1,	/* 148 */
	_nts_26,	/* 149 */
	_nts_1,	/* 150 */
	_nts_28,	/* 151 */
	_nts_28,	/* 152 */
	_nts_28,	/* 153 */
	_nts_28,	/* 154 */
	_nts_28,	/* 155 */
	_nts_28,	/* 156 */
	_nts_28,	/* 157 */
	_nts_28,	/* 158 */
	_nts_1,	/* 159 */
	_nts_1,	/* 160 */
	_nts_27,	/* 161 */
	_nts_1,	/* 162 */
	_nts_10,	/* 163 */
	_nts_1,	/* 164 */
	_nts_0,	/* 165 */
	_nts_1,	/* 166 */
	_nts_11,	/* 167 */
	_nts_29,	/* 168 */
	_nts_0,	/* 169 */
	_nts_30,	/* 170 */
	_nts_30,	/* 171 */
	_nts_30,	/* 172 */
	_nts_30,	/* 173 */
	_nts_30,	/* 174 */
	_nts_30,	/* 175 */
	_nts_30,	/* 176 */
	_nts_30,	/* 177 */
	_nts_30,	/* 178 */
	_nts_30,	/* 179 */
	_nts_14,	/* 180 */
	_nts_14,	/* 181 */
	_nts_14,	/* 182 */
	_nts_14,	/* 183 */
	_nts_14,	/* 184 */
	_nts_14,	/* 185 */
	_nts_14,	/* 186 */
	_nts_14,	/* 187 */
	_nts_14,	/* 188 */
	_nts_14,	/* 189 */
	_nts_26,	/* 190 */
	_nts_1,	/* 191 */
	_nts_31,	/* 192 */
	_nts_31,	/* 193 */
	_nts_31,	/* 194 */
	_nts_31,	/* 195 */
	_nts_31,	/* 196 */
	_nts_31,	/* 197 */
	_nts_31,	/* 198 */
	_nts_31,	/* 199 */
	_nts_31,	/* 200 */
	_nts_31,	/* 201 */
	_nts_31,	/* 202 */
	_nts_31,	/* 203 */
	_nts_29,	/* 204 */
	_nts_29,	/* 205 */
	_nts_29,	/* 206 */
	_nts_29,	/* 207 */
	_nts_1,	/* 208 */
	_nts_1,	/* 209 */
	_nts_1,	/* 210 */
};

static char _arity[] = {
	0,	/* 0 */
	0,	/* 1 */
	0,	/* 2 */
	0,	/* 3 */
	0,	/* 4 */
	0,	/* 5 */
	0,	/* 6 */
	0,	/* 7 */
	0,	/* 8 */
	0,	/* 9 */
	0,	/* 10 */
	0,	/* 11 */
	0,	/* 12 */
	0,	/* 13 */
	0,	/* 14 */
	0,	/* 15 */
	0,	/* 16 */
	0,	/* 17=CNSTF */
	0,	/* 18=CNSTD */
	0,	/* 19=CNSTC */
	0,	/* 20=CNSTS */
	0,	/* 21=CNSTI */
	0,	/* 22=CNSTU */
	0,	/* 23=CNSTP */
	0,	/* 24 */
	0,	/* 25 */
	0,	/* 26 */
	0,	/* 27 */
	0,	/* 28 */
	0,	/* 29 */
	0,	/* 30 */
	0,	/* 31 */
	0,	/* 32 */
	1,	/* 33=ARGF */
	1,	/* 34=ARGD */
	0,	/* 35 */
	0,	/* 36 */
	1,	/* 37=ARGI */
	0,	/* 38 */
	1,	/* 39=ARGP */
	0,	/* 40 */
	1,	/* 41=ARGB */
	0,	/* 42 */
	0,	/* 43 */
	0,	/* 44 */
	0,	/* 45 */
	0,	/* 46 */
	0,	/* 47 */
	0,	/* 48 */
	2,	/* 49=ASGNF */
	2,	/* 50=ASGND */
	2,	/* 51=ASGNC */
	2,	/* 52=ASGNS */
	2,	/* 53=ASGNI */
	0,	/* 54 */
	2,	/* 55=ASGNP */
	0,	/* 56 */
	2,	/* 57=ASGNB */
	0,	/* 58 */
	0,	/* 59 */
	0,	/* 60 */
	0,	/* 61 */
	0,	/* 62 */
	0,	/* 63 */
	0,	/* 64 */
	1,	/* 65=INDIRF */
	1,	/* 66=INDIRD */
	1,	/* 67=INDIRC */
	1,	/* 68=INDIRS */
	1,	/* 69=INDIRI */
	0,	/* 70 */
	1,	/* 71=INDIRP */
	0,	/* 72 */
	1,	/* 73=INDIRB */
	0,	/* 74 */
	0,	/* 75 */
	0,	/* 76 */
	0,	/* 77 */
	0,	/* 78 */
	0,	/* 79 */
	0,	/* 80 */
	0,	/* 81 */
	0,	/* 82 */
	0,	/* 83 */
	0,	/* 84 */
	1,	/* 85=CVCI */
	1,	/* 86=CVCU */
	0,	/* 87 */
	0,	/* 88 */
	0,	/* 89 */
	0,	/* 90 */
	0,	/* 91 */
	0,	/* 92 */
	0,	/* 93 */
	0,	/* 94 */
	0,	/* 95 */
	0,	/* 96 */
	1,	/* 97=CVDF */
	0,	/* 98 */
	0,	/* 99 */
	0,	/* 100 */
	1,	/* 101=CVDI */
	0,	/* 102 */
	0,	/* 103 */
	0,	/* 104 */
	0,	/* 105 */
	0,	/* 106 */
	0,	/* 107 */
	0,	/* 108 */
	0,	/* 109 */
	0,	/* 110 */
	0,	/* 111 */
	0,	/* 112 */
	0,	/* 113 */
	1,	/* 114=CVFD */
	0,	/* 115 */
	0,	/* 116 */
	0,	/* 117 */
	0,	/* 118 */
	0,	/* 119 */
	0,	/* 120 */
	0,	/* 121 */
	0,	/* 122 */
	0,	/* 123 */
	0,	/* 124 */
	0,	/* 125 */
	0,	/* 126 */
	0,	/* 127 */
	0,	/* 128 */
	0,	/* 129 */
	1,	/* 130=CVID */
	1,	/* 131=CVIC */
	1,	/* 132=CVIS */
	0,	/* 133 */
	1,	/* 134=CVIU */
	0,	/* 135 */
	0,	/* 136 */
	0,	/* 137 */
	0,	/* 138 */
	0,	/* 139 */
	0,	/* 140 */
	0,	/* 141 */
	0,	/* 142 */
	0,	/* 143 */
	0,	/* 144 */
	0,	/* 145 */
	0,	/* 146 */
	0,	/* 147 */
	0,	/* 148 */
	0,	/* 149 */
	1,	/* 150=CVPU */
	0,	/* 151 */
	0,	/* 152 */
	0,	/* 153 */
	0,	/* 154 */
	0,	/* 155 */
	0,	/* 156 */
	0,	/* 157 */
	0,	/* 158 */
	0,	/* 159 */
	0,	/* 160 */
	0,	/* 161 */
	0,	/* 162 */
	0,	/* 163 */
	0,	/* 164 */
	1,	/* 165=CVSI */
	1,	/* 166=CVSU */
	0,	/* 167 */
	0,	/* 168 */
	0,	/* 169 */
	0,	/* 170 */
	0,	/* 171 */
	0,	/* 172 */
	0,	/* 173 */
	0,	/* 174 */
	0,	/* 175 */
	0,	/* 176 */
	0,	/* 177 */
	0,	/* 178 */
	1,	/* 179=CVUC */
	1,	/* 180=CVUS */
	1,	/* 181=CVUI */
	0,	/* 182 */
	1,	/* 183=CVUP */
	0,	/* 184 */
	0,	/* 185 */
	0,	/* 186 */
	0,	/* 187 */
	0,	/* 188 */
	0,	/* 189 */
	0,	/* 190 */
	0,	/* 191 */
	0,	/* 192 */
	1,	/* 193=NEGF */
	1,	/* 194=NEGD */
	0,	/* 195 */
	0,	/* 196 */
	1,	/* 197=NEGI */
	0,	/* 198 */
	0,	/* 199 */
	0,	/* 200 */
	0,	/* 201 */
	0,	/* 202 */
	0,	/* 203 */
	0,	/* 204 */
	0,	/* 205 */
	0,	/* 206 */
	0,	/* 207 */
	0,	/* 208 */
	1,	/* 209=CALLF */
	1,	/* 210=CALLD */
	0,	/* 211 */
	0,	/* 212 */
	1,	/* 213=CALLI */
	0,	/* 214 */
	0,	/* 215 */
	1,	/* 216=CALLV */
	0,	/* 217=CALLB */
	0,	/* 218 */
	0,	/* 219 */
	0,	/* 220 */
	0,	/* 221 */
	0,	/* 222 */
	0,	/* 223 */
	0,	/* 224 */
	0,	/* 225=LOADF */
	0,	/* 226=LOADD */
	1,	/* 227=LOADC */
	1,	/* 228=LOADS */
	1,	/* 229=LOADI */
	1,	/* 230=LOADU */
	1,	/* 231=LOADP */
	0,	/* 232 */
	0,	/* 233=LOADB */
	0,	/* 234 */
	0,	/* 235 */
	0,	/* 236 */
	0,	/* 237 */
	0,	/* 238 */
	0,	/* 239 */
	0,	/* 240 */
	1,	/* 241=RETF */
	1,	/* 242=RETD */
	0,	/* 243 */
	0,	/* 244 */
	1,	/* 245=RETI */
	0,	/* 246 */
	0,	/* 247 */
	0,	/* 248 */
	0,	/* 249 */
	0,	/* 250 */
	0,	/* 251 */
	0,	/* 252 */
	0,	/* 253 */
	0,	/* 254 */
	0,	/* 255 */
	0,	/* 256 */
	0,	/* 257 */
	0,	/* 258 */
	0,	/* 259 */
	0,	/* 260 */
	0,	/* 261 */
	0,	/* 262 */
	0,	/* 263=ADDRGP */
	0,	/* 264 */
	0,	/* 265 */
	0,	/* 266 */
	0,	/* 267 */
	0,	/* 268 */
	0,	/* 269 */
	0,	/* 270 */
	0,	/* 271 */
	0,	/* 272 */
	0,	/* 273 */
	0,	/* 274 */
	0,	/* 275 */
	0,	/* 276 */
	0,	/* 277 */
	0,	/* 278 */
	0,	/* 279=ADDRFP */
	0,	/* 280 */
	0,	/* 281 */
	0,	/* 282 */
	0,	/* 283 */
	0,	/* 284 */
	0,	/* 285 */
	0,	/* 286 */
	0,	/* 287 */
	0,	/* 288 */
	0,	/* 289 */
	0,	/* 290 */
	0,	/* 291 */
	0,	/* 292 */
	0,	/* 293 */
	0,	/* 294 */
	0,	/* 295=ADDRLP */
	0,	/* 296 */
	0,	/* 297 */
	0,	/* 298 */
	0,	/* 299 */
	0,	/* 300 */
	0,	/* 301 */
	0,	/* 302 */
	0,	/* 303 */
	0,	/* 304 */
	2,	/* 305=ADDF */
	2,	/* 306=ADDD */
	0,	/* 307 */
	0,	/* 308 */
	2,	/* 309=ADDI */
	2,	/* 310=ADDU */
	2,	/* 311=ADDP */
	0,	/* 312 */
	0,	/* 313 */
	0,	/* 314 */
	0,	/* 315 */
	0,	/* 316 */
	0,	/* 317 */
	0,	/* 318 */
	0,	/* 319 */
	0,	/* 320 */
	2,	/* 321=SUBF */
	2,	/* 322=SUBD */
	0,	/* 323 */
	0,	/* 324 */
	2,	/* 325=SUBI */
	2,	/* 326=SUBU */
	2,	/* 327=SUBP */
	0,	/* 328 */
	0,	/* 329 */
	0,	/* 330 */
	0,	/* 331 */
	0,	/* 332 */
	0,	/* 333 */
	0,	/* 334 */
	0,	/* 335 */
	0,	/* 336 */
	0,	/* 337 */
	0,	/* 338 */
	0,	/* 339 */
	0,	/* 340 */
	2,	/* 341=LSHI */
	2,	/* 342=LSHU */
	0,	/* 343 */
	0,	/* 344 */
	0,	/* 345 */
	0,	/* 346 */
	0,	/* 347 */
	0,	/* 348 */
	0,	/* 349 */
	0,	/* 350 */
	0,	/* 351 */
	0,	/* 352 */
	0,	/* 353 */
	0,	/* 354 */
	0,	/* 355 */
	0,	/* 356 */
	2,	/* 357=MODI */
	2,	/* 358=MODU */
	0,	/* 359 */
	0,	/* 360 */
	0,	/* 361 */
	0,	/* 362 */
	0,	/* 363 */
	0,	/* 364 */
	0,	/* 365 */
	0,	/* 366 */
	0,	/* 367 */
	0,	/* 368 */
	0,	/* 369 */
	0,	/* 370 */
	0,	/* 371 */
	0,	/* 372 */
	2,	/* 373=RSHI */
	2,	/* 374=RSHU */
	0,	/* 375 */
	0,	/* 376 */
	0,	/* 377 */
	0,	/* 378 */
	0,	/* 379 */
	0,	/* 380 */
	0,	/* 381 */
	0,	/* 382 */
	0,	/* 383 */
	0,	/* 384 */
	0,	/* 385 */
	0,	/* 386 */
	0,	/* 387 */
	0,	/* 388 */
	0,	/* 389 */
	2,	/* 390=BANDU */
	0,	/* 391 */
	0,	/* 392 */
	0,	/* 393 */
	0,	/* 394 */
	0,	/* 395 */
	0,	/* 396 */
	0,	/* 397 */
	0,	/* 398 */
	0,	/* 399 */
	0,	/* 400 */
	0,	/* 401 */
	0,	/* 402 */
	0,	/* 403 */
	0,	/* 404 */
	0,	/* 405 */
	1,	/* 406=BCOMU */
	0,	/* 407 */
	0,	/* 408 */
	0,	/* 409 */
	0,	/* 410 */
	0,	/* 411 */
	0,	/* 412 */
	0,	/* 413 */
	0,	/* 414 */
	0,	/* 415 */
	0,	/* 416 */
	0,	/* 417 */
	0,	/* 418 */
	0,	/* 419 */
	0,	/* 420 */
	0,	/* 421 */
	2,	/* 422=BORU */
	0,	/* 423 */
	0,	/* 424 */
	0,	/* 425 */
	0,	/* 426 */
	0,	/* 427 */
	0,	/* 428 */
	0,	/* 429 */
	0,	/* 430 */
	0,	/* 431 */
	0,	/* 432 */
	0,	/* 433 */
	0,	/* 434 */
	0,	/* 435 */
	0,	/* 436 */
	0,	/* 437 */
	2,	/* 438=BXORU */
	0,	/* 439 */
	0,	/* 440 */
	0,	/* 441 */
	0,	/* 442 */
	0,	/* 443 */
	0,	/* 444 */
	0,	/* 445 */
	0,	/* 446 */
	0,	/* 447 */
	0,	/* 448 */
	2,	/* 449=DIVF */
	2,	/* 450=DIVD */
	0,	/* 451 */
	0,	/* 452 */
	2,	/* 453=DIVI */
	2,	/* 454=DIVU */
	0,	/* 455 */
	0,	/* 456 */
	0,	/* 457 */
	0,	/* 458 */
	0,	/* 459 */
	0,	/* 460 */
	0,	/* 461 */
	0,	/* 462 */
	0,	/* 463 */
	0,	/* 464 */
	2,	/* 465=MULF */
	2,	/* 466=MULD */
	0,	/* 467 */
	0,	/* 468 */
	2,	/* 469=MULI */
	2,	/* 470=MULU */
	0,	/* 471 */
	0,	/* 472 */
	0,	/* 473 */
	0,	/* 474 */
	0,	/* 475 */
	0,	/* 476 */
	0,	/* 477 */
	0,	/* 478 */
	0,	/* 479 */
	0,	/* 480 */
	2,	/* 481=EQF */
	2,	/* 482=EQD */
	0,	/* 483 */
	0,	/* 484 */
	2,	/* 485=EQI */
	0,	/* 486 */
	0,	/* 487 */
	0,	/* 488 */
	0,	/* 489 */
	0,	/* 490 */
	0,	/* 491 */
	0,	/* 492 */
	0,	/* 493 */
	0,	/* 494 */
	0,	/* 495 */
	0,	/* 496 */
	2,	/* 497=GEF */
	2,	/* 498=GED */
	0,	/* 499 */
	0,	/* 500 */
	2,	/* 501=GEI */
	2,	/* 502=GEU */
	0,	/* 503 */
	0,	/* 504 */
	0,	/* 505 */
	0,	/* 506 */
	0,	/* 507 */
	0,	/* 508 */
	0,	/* 509 */
	0,	/* 510 */
	0,	/* 511 */
	0,	/* 512 */
	2,	/* 513=GTF */
	2,	/* 514=GTD */
	0,	/* 515 */
	0,	/* 516 */
	2,	/* 517=GTI */
	2,	/* 518=GTU */
	0,	/* 519 */
	0,	/* 520 */
	0,	/* 521 */
	0,	/* 522 */
	0,	/* 523 */
	0,	/* 524 */
	0,	/* 525 */
	0,	/* 526 */
	0,	/* 527 */
	0,	/* 528 */
	2,	/* 529=LEF */
	2,	/* 530=LED */
	0,	/* 531 */
	0,	/* 532 */
	2,	/* 533=LEI */
	2,	/* 534=LEU */
	0,	/* 535 */
	0,	/* 536 */
	0,	/* 537 */
	0,	/* 538 */
	0,	/* 539 */
	0,	/* 540 */
	0,	/* 541 */
	0,	/* 542 */
	0,	/* 543 */
	0,	/* 544 */
	2,	/* 545=LTF */
	2,	/* 546=LTD */
	0,	/* 547 */
	0,	/* 548 */
	2,	/* 549=LTI */
	2,	/* 550=LTU */
	0,	/* 551 */
	0,	/* 552 */
	0,	/* 553 */
	0,	/* 554 */
	0,	/* 555 */
	0,	/* 556 */
	0,	/* 557 */
	0,	/* 558 */
	0,	/* 559 */
	0,	/* 560 */
	2,	/* 561=NEF */
	2,	/* 562=NED */
	0,	/* 563 */
	0,	/* 564 */
	2,	/* 565=NEI */
	0,	/* 566 */
	0,	/* 567 */
	0,	/* 568 */
	0,	/* 569 */
	0,	/* 570 */
	0,	/* 571 */
	0,	/* 572 */
	0,	/* 573 */
	0,	/* 574 */
	0,	/* 575 */
	0,	/* 576 */
	0,	/* 577 */
	0,	/* 578 */
	0,	/* 579 */
	0,	/* 580 */
	0,	/* 581 */
	0,	/* 582 */
	0,	/* 583 */
	1,	/* 584=JUMPV */
	0,	/* 585 */
	0,	/* 586 */
	0,	/* 587 */
	0,	/* 588 */
	0,	/* 589 */
	0,	/* 590 */
	0,	/* 591 */
	0,	/* 592 */
	0,	/* 593 */
	0,	/* 594 */
	0,	/* 595 */
	0,	/* 596 */
	0,	/* 597 */
	0,	/* 598 */
	0,	/* 599 */
	0,	/* 600=LABELV */
	0,	/* 601 */
	0,	/* 602 */
	0,	/* 603 */
	0,	/* 604 */
	0,	/* 605 */
	0,	/* 606 */
	0,	/* 607 */
	0,	/* 608 */
	0,	/* 609 */
	0,	/* 610 */
	0,	/* 611 */
	0,	/* 612 */
	0,	/* 613 */
	0,	/* 614 */
	0,	/* 615=VREGP */
};

static char *_opname[] = {
/* 0 */	0,
/* 1 */	0,
/* 2 */	0,
/* 3 */	0,
/* 4 */	0,
/* 5 */	0,
/* 6 */	0,
/* 7 */	0,
/* 8 */	0,
/* 9 */	0,
/* 10 */	0,
/* 11 */	0,
/* 12 */	0,
/* 13 */	0,
/* 14 */	0,
/* 15 */	0,
/* 16 */	0,
/* 17 */	"CNSTF",
/* 18 */	"CNSTD",
/* 19 */	"CNSTC",
/* 20 */	"CNSTS",
/* 21 */	"CNSTI",
/* 22 */	"CNSTU",
/* 23 */	"CNSTP",
/* 24 */	0,
/* 25 */	0,
/* 26 */	0,
/* 27 */	0,
/* 28 */	0,
/* 29 */	0,
/* 30 */	0,
/* 31 */	0,
/* 32 */	0,
/* 33 */	"ARGF",
/* 34 */	"ARGD",
/* 35 */	0,
/* 36 */	0,
/* 37 */	"ARGI",
/* 38 */	0,
/* 39 */	"ARGP",
/* 40 */	0,
/* 41 */	"ARGB",
/* 42 */	0,
/* 43 */	0,
/* 44 */	0,
/* 45 */	0,
/* 46 */	0,
/* 47 */	0,
/* 48 */	0,
/* 49 */	"ASGNF",
/* 50 */	"ASGND",
/* 51 */	"ASGNC",
/* 52 */	"ASGNS",
/* 53 */	"ASGNI",
/* 54 */	0,
/* 55 */	"ASGNP",
/* 56 */	0,
/* 57 */	"ASGNB",
/* 58 */	0,
/* 59 */	0,
/* 60 */	0,
/* 61 */	0,
/* 62 */	0,
/* 63 */	0,
/* 64 */	0,
/* 65 */	"INDIRF",
/* 66 */	"INDIRD",
/* 67 */	"INDIRC",
/* 68 */	"INDIRS",
/* 69 */	"INDIRI",
/* 70 */	0,
/* 71 */	"INDIRP",
/* 72 */	0,
/* 73 */	"INDIRB",
/* 74 */	0,
/* 75 */	0,
/* 76 */	0,
/* 77 */	0,
/* 78 */	0,
/* 79 */	0,
/* 80 */	0,
/* 81 */	0,
/* 82 */	0,
/* 83 */	0,
/* 84 */	0,
/* 85 */	"CVCI",
/* 86 */	"CVCU",
/* 87 */	0,
/* 88 */	0,
/* 89 */	0,
/* 90 */	0,
/* 91 */	0,
/* 92 */	0,
/* 93 */	0,
/* 94 */	0,
/* 95 */	0,
/* 96 */	0,
/* 97 */	"CVDF",
/* 98 */	0,
/* 99 */	0,
/* 100 */	0,
/* 101 */	"CVDI",
/* 102 */	0,
/* 103 */	0,
/* 104 */	0,
/* 105 */	0,
/* 106 */	0,
/* 107 */	0,
/* 108 */	0,
/* 109 */	0,
/* 110 */	0,
/* 111 */	0,
/* 112 */	0,
/* 113 */	0,
/* 114 */	"CVFD",
/* 115 */	0,
/* 116 */	0,
/* 117 */	0,
/* 118 */	0,
/* 119 */	0,
/* 120 */	0,
/* 121 */	0,
/* 122 */	0,
/* 123 */	0,
/* 124 */	0,
/* 125 */	0,
/* 126 */	0,
/* 127 */	0,
/* 128 */	0,
/* 129 */	0,
/* 130 */	"CVID",
/* 131 */	"CVIC",
/* 132 */	"CVIS",
/* 133 */	0,
/* 134 */	"CVIU",
/* 135 */	0,
/* 136 */	0,
/* 137 */	0,
/* 138 */	0,
/* 139 */	0,
/* 140 */	0,
/* 141 */	0,
/* 142 */	0,
/* 143 */	0,
/* 144 */	0,
/* 145 */	0,
/* 146 */	0,
/* 147 */	0,
/* 148 */	0,
/* 149 */	0,
/* 150 */	"CVPU",
/* 151 */	0,
/* 152 */	0,
/* 153 */	0,
/* 154 */	0,
/* 155 */	0,
/* 156 */	0,
/* 157 */	0,
/* 158 */	0,
/* 159 */	0,
/* 160 */	0,
/* 161 */	0,
/* 162 */	0,
/* 163 */	0,
/* 164 */	0,
/* 165 */	"CVSI",
/* 166 */	"CVSU",
/* 167 */	0,
/* 168 */	0,
/* 169 */	0,
/* 170 */	0,
/* 171 */	0,
/* 172 */	0,
/* 173 */	0,
/* 174 */	0,
/* 175 */	0,
/* 176 */	0,
/* 177 */	0,
/* 178 */	0,
/* 179 */	"CVUC",
/* 180 */	"CVUS",
/* 181 */	"CVUI",
/* 182 */	0,
/* 183 */	"CVUP",
/* 184 */	0,
/* 185 */	0,
/* 186 */	0,
/* 187 */	0,
/* 188 */	0,
/* 189 */	0,
/* 190 */	0,
/* 191 */	0,
/* 192 */	0,
/* 193 */	"NEGF",
/* 194 */	"NEGD",
/* 195 */	0,
/* 196 */	0,
/* 197 */	"NEGI",
/* 198 */	0,
/* 199 */	0,
/* 200 */	0,
/* 201 */	0,
/* 202 */	0,
/* 203 */	0,
/* 204 */	0,
/* 205 */	0,
/* 206 */	0,
/* 207 */	0,
/* 208 */	0,
/* 209 */	"CALLF",
/* 210 */	"CALLD",
/* 211 */	0,
/* 212 */	0,
/* 213 */	"CALLI",
/* 214 */	0,
/* 215 */	0,
/* 216 */	"CALLV",
/* 217 */	"CALLB",
/* 218 */	0,
/* 219 */	0,
/* 220 */	0,
/* 221 */	0,
/* 222 */	0,
/* 223 */	0,
/* 224 */	0,
/* 225 */	"LOADF",
/* 226 */	"LOADD",
/* 227 */	"LOADC",
/* 228 */	"LOADS",
/* 229 */	"LOADI",
/* 230 */	"LOADU",
/* 231 */	"LOADP",
/* 232 */	0,
/* 233 */	"LOADB",
/* 234 */	0,
/* 235 */	0,
/* 236 */	0,
/* 237 */	0,
/* 238 */	0,
/* 239 */	0,
/* 240 */	0,
/* 241 */	"RETF",
/* 242 */	"RETD",
/* 243 */	0,
/* 244 */	0,
/* 245 */	"RETI",
/* 246 */	0,
/* 247 */	0,
/* 248 */	0,
/* 249 */	0,
/* 250 */	0,
/* 251 */	0,
/* 252 */	0,
/* 253 */	0,
/* 254 */	0,
/* 255 */	0,
/* 256 */	0,
/* 257 */	0,
/* 258 */	0,
/* 259 */	0,
/* 260 */	0,
/* 261 */	0,
/* 262 */	0,
/* 263 */	"ADDRGP",
/* 264 */	0,
/* 265 */	0,
/* 266 */	0,
/* 267 */	0,
/* 268 */	0,
/* 269 */	0,
/* 270 */	0,
/* 271 */	0,
/* 272 */	0,
/* 273 */	0,
/* 274 */	0,
/* 275 */	0,
/* 276 */	0,
/* 277 */	0,
/* 278 */	0,
/* 279 */	"ADDRFP",
/* 280 */	0,
/* 281 */	0,
/* 282 */	0,
/* 283 */	0,
/* 284 */	0,
/* 285 */	0,
/* 286 */	0,
/* 287 */	0,
/* 288 */	0,
/* 289 */	0,
/* 290 */	0,
/* 291 */	0,
/* 292 */	0,
/* 293 */	0,
/* 294 */	0,
/* 295 */	"ADDRLP",
/* 296 */	0,
/* 297 */	0,
/* 298 */	0,
/* 299 */	0,
/* 300 */	0,
/* 301 */	0,
/* 302 */	0,
/* 303 */	0,
/* 304 */	0,
/* 305 */	"ADDF",
/* 306 */	"ADDD",
/* 307 */	0,
/* 308 */	0,
/* 309 */	"ADDI",
/* 310 */	"ADDU",
/* 311 */	"ADDP",
/* 312 */	0,
/* 313 */	0,
/* 314 */	0,
/* 315 */	0,
/* 316 */	0,
/* 317 */	0,
/* 318 */	0,
/* 319 */	0,
/* 320 */	0,
/* 321 */	"SUBF",
/* 322 */	"SUBD",
/* 323 */	0,
/* 324 */	0,
/* 325 */	"SUBI",
/* 326 */	"SUBU",
/* 327 */	"SUBP",
/* 328 */	0,
/* 329 */	0,
/* 330 */	0,
/* 331 */	0,
/* 332 */	0,
/* 333 */	0,
/* 334 */	0,
/* 335 */	0,
/* 336 */	0,
/* 337 */	0,
/* 338 */	0,
/* 339 */	0,
/* 340 */	0,
/* 341 */	"LSHI",
/* 342 */	"LSHU",
/* 343 */	0,
/* 344 */	0,
/* 345 */	0,
/* 346 */	0,
/* 347 */	0,
/* 348 */	0,
/* 349 */	0,
/* 350 */	0,
/* 351 */	0,
/* 352 */	0,
/* 353 */	0,
/* 354 */	0,
/* 355 */	0,
/* 356 */	0,
/* 357 */	"MODI",
/* 358 */	"MODU",
/* 359 */	0,
/* 360 */	0,
/* 361 */	0,
/* 362 */	0,
/* 363 */	0,
/* 364 */	0,
/* 365 */	0,
/* 366 */	0,
/* 367 */	0,
/* 368 */	0,
/* 369 */	0,
/* 370 */	0,
/* 371 */	0,
/* 372 */	0,
/* 373 */	"RSHI",
/* 374 */	"RSHU",
/* 375 */	0,
/* 376 */	0,
/* 377 */	0,
/* 378 */	0,
/* 379 */	0,
/* 380 */	0,
/* 381 */	0,
/* 382 */	0,
/* 383 */	0,
/* 384 */	0,
/* 385 */	0,
/* 386 */	0,
/* 387 */	0,
/* 388 */	0,
/* 389 */	0,
/* 390 */	"BANDU",
/* 391 */	0,
/* 392 */	0,
/* 393 */	0,
/* 394 */	0,
/* 395 */	0,
/* 396 */	0,
/* 397 */	0,
/* 398 */	0,
/* 399 */	0,
/* 400 */	0,
/* 401 */	0,
/* 402 */	0,
/* 403 */	0,
/* 404 */	0,
/* 405 */	0,
/* 406 */	"BCOMU",
/* 407 */	0,
/* 408 */	0,
/* 409 */	0,
/* 410 */	0,
/* 411 */	0,
/* 412 */	0,
/* 413 */	0,
/* 414 */	0,
/* 415 */	0,
/* 416 */	0,
/* 417 */	0,
/* 418 */	0,
/* 419 */	0,
/* 420 */	0,
/* 421 */	0,
/* 422 */	"BORU",
/* 423 */	0,
/* 424 */	0,
/* 425 */	0,
/* 426 */	0,
/* 427 */	0,
/* 428 */	0,
/* 429 */	0,
/* 430 */	0,
/* 431 */	0,
/* 432 */	0,
/* 433 */	0,
/* 434 */	0,
/* 435 */	0,
/* 436 */	0,
/* 437 */	0,
/* 438 */	"BXORU",
/* 439 */	0,
/* 440 */	0,
/* 441 */	0,
/* 442 */	0,
/* 443 */	0,
/* 444 */	0,
/* 445 */	0,
/* 446 */	0,
/* 447 */	0,
/* 448 */	0,
/* 449 */	"DIVF",
/* 450 */	"DIVD",
/* 451 */	0,
/* 452 */	0,
/* 453 */	"DIVI",
/* 454 */	"DIVU",
/* 455 */	0,
/* 456 */	0,
/* 457 */	0,
/* 458 */	0,
/* 459 */	0,
/* 460 */	0,
/* 461 */	0,
/* 462 */	0,
/* 463 */	0,
/* 464 */	0,
/* 465 */	"MULF",
/* 466 */	"MULD",
/* 467 */	0,
/* 468 */	0,
/* 469 */	"MULI",
/* 470 */	"MULU",
/* 471 */	0,
/* 472 */	0,
/* 473 */	0,
/* 474 */	0,
/* 475 */	0,
/* 476 */	0,
/* 477 */	0,
/* 478 */	0,
/* 479 */	0,
/* 480 */	0,
/* 481 */	"EQF",
/* 482 */	"EQD",
/* 483 */	0,
/* 484 */	0,
/* 485 */	"EQI",
/* 486 */	0,
/* 487 */	0,
/* 488 */	0,
/* 489 */	0,
/* 490 */	0,
/* 491 */	0,
/* 492 */	0,
/* 493 */	0,
/* 494 */	0,
/* 495 */	0,
/* 496 */	0,
/* 497 */	"GEF",
/* 498 */	"GED",
/* 499 */	0,
/* 500 */	0,
/* 501 */	"GEI",
/* 502 */	"GEU",
/* 503 */	0,
/* 504 */	0,
/* 505 */	0,
/* 506 */	0,
/* 507 */	0,
/* 508 */	0,
/* 509 */	0,
/* 510 */	0,
/* 511 */	0,
/* 512 */	0,
/* 513 */	"GTF",
/* 514 */	"GTD",
/* 515 */	0,
/* 516 */	0,
/* 517 */	"GTI",
/* 518 */	"GTU",
/* 519 */	0,
/* 520 */	0,
/* 521 */	0,
/* 522 */	0,
/* 523 */	0,
/* 524 */	0,
/* 525 */	0,
/* 526 */	0,
/* 527 */	0,
/* 528 */	0,
/* 529 */	"LEF",
/* 530 */	"LED",
/* 531 */	0,
/* 532 */	0,
/* 533 */	"LEI",
/* 534 */	"LEU",
/* 535 */	0,
/* 536 */	0,
/* 537 */	0,
/* 538 */	0,
/* 539 */	0,
/* 540 */	0,
/* 541 */	0,
/* 542 */	0,
/* 543 */	0,
/* 544 */	0,
/* 545 */	"LTF",
/* 546 */	"LTD",
/* 547 */	0,
/* 548 */	0,
/* 549 */	"LTI",
/* 550 */	"LTU",
/* 551 */	0,
/* 552 */	0,
/* 553 */	0,
/* 554 */	0,
/* 555 */	0,
/* 556 */	0,
/* 557 */	0,
/* 558 */	0,
/* 559 */	0,
/* 560 */	0,
/* 561 */	"NEF",
/* 562 */	"NED",
/* 563 */	0,
/* 564 */	0,
/* 565 */	"NEI",
/* 566 */	0,
/* 567 */	0,
/* 568 */	0,
/* 569 */	0,
/* 570 */	0,
/* 571 */	0,
/* 572 */	0,
/* 573 */	0,
/* 574 */	0,
/* 575 */	0,
/* 576 */	0,
/* 577 */	0,
/* 578 */	0,
/* 579 */	0,
/* 580 */	0,
/* 581 */	0,
/* 582 */	0,
/* 583 */	0,
/* 584 */	"JUMPV",
/* 585 */	0,
/* 586 */	0,
/* 587 */	0,
/* 588 */	0,
/* 589 */	0,
/* 590 */	0,
/* 591 */	0,
/* 592 */	0,
/* 593 */	0,
/* 594 */	0,
/* 595 */	0,
/* 596 */	0,
/* 597 */	0,
/* 598 */	0,
/* 599 */	0,
/* 600 */	"LABELV",
/* 601 */	0,
/* 602 */	0,
/* 603 */	0,
/* 604 */	0,
/* 605 */	0,
/* 606 */	0,
/* 607 */	0,
/* 608 */	0,
/* 609 */	0,
/* 610 */	0,
/* 611 */	0,
/* 612 */	0,
/* 613 */	0,
/* 614 */	0,
/* 615 */	"VREGP",
};

static char *_templates[] = {
/* 0 */	0,
/* 1 */	"# read register\n",	/* reg: INDIRC(VREGP) */
/* 2 */	"# read register\n",	/* reg: INDIRD(VREGP) */
/* 3 */	"# read register\n",	/* reg: INDIRF(VREGP) */
/* 4 */	"# read register\n",	/* reg: INDIRI(VREGP) */
/* 5 */	"# read register\n",	/* reg: INDIRP(VREGP) */
/* 6 */	"# read register\n",	/* reg: INDIRS(VREGP) */
/* 7 */	"# write register\n",	/* stmt: ASGNC(VREGP,reg) */
/* 8 */	"# write register\n",	/* stmt: ASGND(VREGP,reg) */
/* 9 */	"# write register\n",	/* stmt: ASGNF(VREGP,reg) */
/* 10 */	"# write register\n",	/* stmt: ASGNI(VREGP,reg) */
/* 11 */	"# write register\n",	/* stmt: ASGNP(VREGP,reg) */
/* 12 */	"# write register\n",	/* stmt: ASGNS(VREGP,reg) */
/* 13 */	"%a",	/* con: CNSTC */
/* 14 */	"%a",	/* con: CNSTI */
/* 15 */	"%a",	/* con: CNSTP */
/* 16 */	"%a",	/* con: CNSTS */
/* 17 */	"%a",	/* con: CNSTU */
/* 18 */	"",	/* stmt: reg */
/* 19 */	"%0",	/* reg: CVIU(reg) */
/* 20 */	"%0",	/* reg: CVPU(reg) */
/* 21 */	"%0",	/* reg: CVUI(reg) */
/* 22 */	"%0",	/* reg: CVUP(reg) */
/* 23 */	"%a",	/* acon: ADDRGP */
/* 24 */	"%0",	/* acon: con */
/* 25 */	"%a",	/* base: ADDRGP */
/* 26 */	"[%0]",	/* base: reg */
/* 27 */	"%1[%0]",	/* base: ADDI(reg,acon) */
/* 28 */	"%1[%0]",	/* base: ADDP(reg,acon) */
/* 29 */	"%1[%0]",	/* base: ADDU(reg,acon) */
/* 30 */	"%a[ebp]",	/* base: ADDRFP */
/* 31 */	"%a[ebp]",	/* base: ADDRLP */
/* 32 */	"%0",	/* index: reg */
/* 33 */	"%0*2",	/* index: LSHI(reg,con1) */
/* 34 */	"%0*4",	/* index: LSHI(reg,con2) */
/* 35 */	"%0*8",	/* index: LSHI(reg,con3) */
/* 36 */	"1",	/* con1: CNSTI */
/* 37 */	"1",	/* con1: CNSTU */
/* 38 */	"2",	/* con2: CNSTI */
/* 39 */	"2",	/* con2: CNSTU */
/* 40 */	"3",	/* con3: CNSTI */
/* 41 */	"3",	/* con3: CNSTU */
/* 42 */	"%0*2",	/* index: LSHU(reg,con1) */
/* 43 */	"%0*4",	/* index: LSHU(reg,con2) */
/* 44 */	"%0*8",	/* index: LSHU(reg,con3) */
/* 45 */	"%0",	/* addr: base */
/* 46 */	"%1[%0]",	/* addr: ADDI(index,base) */
/* 47 */	"%1[%0]",	/* addr: ADDP(index,base) */
/* 48 */	"%1[%0]",	/* addr: ADDU(index,base) */
/* 49 */	"[%0]",	/* addr: index */
/* 50 */	"byte ptr %0",	/* mem: INDIRC(addr) */
/* 51 */	"dword ptr %0",	/* mem: INDIRI(addr) */
/* 52 */	"dword ptr %0",	/* mem: INDIRP(addr) */
/* 53 */	"word ptr %0",	/* mem: INDIRS(addr) */
/* 54 */	"%0",	/* rc: reg */
/* 55 */	"%0",	/* rc: con */
/* 56 */	"%0",	/* mr: reg */
/* 57 */	"%0",	/* mr: mem */
/* 58 */	"%0",	/* mrc0: mem */
/* 59 */	"%0",	/* mrc0: rc */
/* 60 */	"%0",	/* mrc1: mem */
/* 61 */	"%0",	/* mrc1: rc */
/* 62 */	"%0",	/* mrc3: mem */
/* 63 */	"%0",	/* mrc3: rc */
/* 64 */	"lea %c,%0\n",	/* reg: addr */
/* 65 */	"mov %c,%0\n",	/* reg: mrc0 */
/* 66 */	"mov %c,%0\n",	/* reg: LOADC(reg) */
/* 67 */	"mov %c,%0\n",	/* reg: LOADI(reg) */
/* 68 */	"mov %c,%0\n",	/* reg: LOADP(reg) */
/* 69 */	"mov %c,%0\n",	/* reg: LOADS(reg) */
/* 70 */	"mov %c,%0\n",	/* reg: LOADU(reg) */
/* 71 */	"?mov %c,%0\nadd %c,%1\n",	/* reg: ADDI(reg,mrc1) */
/* 72 */	"?mov %c,%0\nadd %c,%1\n",	/* reg: ADDP(reg,mrc1) */
/* 73 */	"?mov %c,%0\nadd %c,%1\n",	/* reg: ADDU(reg,mrc1) */
/* 74 */	"?mov %c,%0\nsub %c,%1\n",	/* reg: SUBI(reg,mrc1) */
/* 75 */	"?mov %c,%0\nsub %c,%1\n",	/* reg: SUBP(reg,mrc1) */
/* 76 */	"?mov %c,%0\nsub %c,%1\n",	/* reg: SUBU(reg,mrc1) */
/* 77 */	"?mov %c,%0\nand %c,%1\n",	/* reg: BANDU(reg,mrc1) */
/* 78 */	"?mov %c,%0\nor %c,%1\n",	/* reg: BORU(reg,mrc1) */
/* 79 */	"?mov %c,%0\nxor %c,%1\n",	/* reg: BXORU(reg,mrc1) */
/* 80 */	"inc %1\n",	/* stmt: ASGNI(addr,ADDI(mem,con1)) */
/* 81 */	"inc %1\n",	/* stmt: ASGNI(addr,ADDU(mem,con1)) */
/* 82 */	"inc %1\n",	/* stmt: ASGNP(addr,ADDP(mem,con1)) */
/* 83 */	"dec %1\n",	/* stmt: ASGNI(addr,SUBI(mem,con1)) */
/* 84 */	"dec %1\n",	/* stmt: ASGNI(addr,SUBU(mem,con1)) */
/* 85 */	"dec %1\n",	/* stmt: ASGNP(addr,SUBP(mem,con1)) */
/* 86 */	"add %1,%2\n",	/* stmt: ASGNI(addr,ADDI(mem,rc)) */
/* 87 */	"add %1,%2\n",	/* stmt: ASGNI(addr,ADDU(mem,rc)) */
/* 88 */	"sub %1,%2\n",	/* stmt: ASGNI(addr,SUBI(mem,rc)) */
/* 89 */	"sub %1,%2\n",	/* stmt: ASGNI(addr,SUBU(mem,rc)) */
/* 90 */	"and %1,%2\n",	/* stmt: ASGNI(addr,BANDU(mem,rc)) */
/* 91 */	"or %1,%2\n",	/* stmt: ASGNI(addr,BORU(mem,rc)) */
/* 92 */	"xor %1,%2\n",	/* stmt: ASGNI(addr,BXORU(mem,rc)) */
/* 93 */	"?mov %c,%0\nnot %c\n",	/* reg: BCOMU(reg) */
/* 94 */	"?mov %c,%0\nneg %c\n",	/* reg: NEGI(reg) */
/* 95 */	"not %1\n",	/* stmt: ASGNI(addr,BCOMU(mem)) */
/* 96 */	"neg %1\n",	/* stmt: ASGNI(addr,NEGI(mem)) */
/* 97 */	"?mov %c,%0\nsal %c,%1\n",	/* reg: LSHI(reg,rc5) */
/* 98 */	"?mov %c,%0\nshl %c,%1\n",	/* reg: LSHU(reg,rc5) */
/* 99 */	"?mov %c,%0\nsar %c,%1\n",	/* reg: RSHI(reg,rc5) */
/* 100 */	"?mov %c,%0\nshr %c,%1\n",	/* reg: RSHU(reg,rc5) */
/* 101 */	"sal %1,%2\n",	/* stmt: ASGNI(addr,LSHI(mem,rc5)) */
/* 102 */	"shl %1,%2\n",	/* stmt: ASGNI(addr,LSHU(mem,rc5)) */
/* 103 */	"sar %1,%2\n",	/* stmt: ASGNI(addr,RSHI(mem,rc5)) */
/* 104 */	"shr %1,%2\n",	/* stmt: ASGNI(addr,RSHU(mem,rc5)) */
/* 105 */	"%a",	/* rc5: CNSTI */
/* 106 */	"cl",	/* rc5: reg */
/* 107 */	"?mov %c,%0\nimul %c,%1\n",	/* reg: MULI(reg,mrc3) */
/* 108 */	"imul %c,%1,%0\n",	/* reg: MULI(con,mr) */
/* 109 */	"mul %1\n",	/* reg: MULU(reg,mr) */
/* 110 */	"xor edx,edx\ndiv %1\n",	/* reg: DIVU(reg,reg) */
/* 111 */	"xor edx,edx\ndiv %1\n",	/* reg: MODU(reg,reg) */
/* 112 */	"cdq\nidiv %1\n",	/* reg: DIVI(reg,reg) */
/* 113 */	"cdq\nidiv %1\n",	/* reg: MODI(reg,reg) */
/* 114 */	"mov %c,%0\n",	/* reg: CVIU(reg) */
/* 115 */	"mov %c,%0\n",	/* reg: CVPU(reg) */
/* 116 */	"mov %c,%0\n",	/* reg: CVUI(reg) */
/* 117 */	"mov %c,%0\n",	/* reg: CVUP(reg) */
/* 118 */	"movsx %c,byte ptr %0\n",	/* reg: CVCI(INDIRC(addr)) */
/* 119 */	"movzx %c,byte ptr %0\n",	/* reg: CVCU(INDIRC(addr)) */
/* 120 */	"movsx %c,word ptr %0\n",	/* reg: CVSI(INDIRS(addr)) */
/* 121 */	"movzx %c,word ptr %0\n",	/* reg: CVSU(INDIRS(addr)) */
/* 122 */	"# extend\n",	/* reg: CVCI(reg) */
/* 123 */	"# extend\n",	/* reg: CVCU(reg) */
/* 124 */	"# extend\n",	/* reg: CVSI(reg) */
/* 125 */	"# extend\n",	/* reg: CVSU(reg) */
/* 126 */	"# truncate\n",	/* reg: CVIC(reg) */
/* 127 */	"# truncate\n",	/* reg: CVIS(reg) */
/* 128 */	"# truncate\n",	/* reg: CVUC(reg) */
/* 129 */	"# truncate\n",	/* reg: CVUS(reg) */
/* 130 */	"mov byte ptr %0,%1\n",	/* stmt: ASGNC(addr,rc) */
/* 131 */	"mov dword ptr %0,%1\n",	/* stmt: ASGNI(addr,rc) */
/* 132 */	"mov dword ptr %0,%1\n",	/* stmt: ASGNP(addr,rc) */
/* 133 */	"mov word ptr %0,%1\n",	/* stmt: ASGNS(addr,rc) */
/* 134 */	"push %0\n",	/* stmt: ARGI(mrc3) */
/* 135 */	"push %0\n",	/* stmt: ARGP(mrc3) */
/* 136 */	"mov ecx,%a\nrep movsb\n",	/* stmt: ASGNB(reg,INDIRB(reg)) */
/* 137 */	"sub esp,%a\nmov edi,esp\nmov ecx,%a\nrep movsb\n",	/* stmt: ARGB(INDIRB(reg)) */
/* 138 */	"qword ptr %0",	/* memf: INDIRD(addr) */
/* 139 */	"dword ptr %0",	/* memf: INDIRF(addr) */
/* 140 */	"dword ptr %0",	/* memf: CVFD(INDIRF(addr)) */
/* 141 */	"fld %0\n",	/* reg: memf */
/* 142 */	"fstp qword ptr %0\n",	/* stmt: ASGND(addr,reg) */
/* 143 */	"fstp dword ptr %0\n",	/* stmt: ASGNF(addr,reg) */
/* 144 */	"fstp dword ptr %0\n",	/* stmt: ASGNF(addr,CVDF(reg)) */
/* 145 */	"sub esp,8\nfstp qword ptr [esp]\n",	/* stmt: ARGD(reg) */
/* 146 */	"sub esp,4\nfstp dword ptr [esp]\n",	/* stmt: ARGF(reg) */
/* 147 */	"fchs\n",	/* reg: NEGD(reg) */
/* 148 */	"fchs\n",	/* reg: NEGF(reg) */
/* 149 */	" %0",	/* flt: memf */
/* 150 */	"p st(1),st",	/* flt: reg */
/* 151 */	"fadd%1\n",	/* reg: ADDD(reg,flt) */
/* 152 */	"fadd%1\n",	/* reg: ADDF(reg,flt) */
/* 153 */	"fdiv%1\n",	/* reg: DIVD(reg,flt) */
/* 154 */	"fdiv%1\n",	/* reg: DIVF(reg,flt) */
/* 155 */	"fmul%1\n",	/* reg: MULD(reg,flt) */
/* 156 */	"fmul%1\n",	/* reg: MULF(reg,flt) */
/* 157 */	"fsub%1\n",	/* reg: SUBD(reg,flt) */
/* 158 */	"fsub%1\n",	/* reg: SUBF(reg,flt) */
/* 159 */	"# CVFD\n",	/* reg: CVFD(reg) */
/* 160 */	"sub esp,4\nfstp dword ptr 0[esp]\nfld dword ptr 0[esp]\nadd esp,4\n",	/* reg: CVDF(reg) */
/* 161 */	"fistp dword ptr %0\n",	/* stmt: ASGNI(addr,CVDI(reg)) */
/* 162 */	"sub esp,4\nfistp dword ptr 0[esp]\npop %c\n",	/* reg: CVDI(reg) */
/* 163 */	"fild dword ptr %0\n",	/* reg: CVID(INDIRI(addr)) */
/* 164 */	"push %0\nfild dword ptr 0[esp]\nadd esp,4\n",	/* reg: CVID(reg) */
/* 165 */	"%a",	/* addrj: ADDRGP */
/* 166 */	"%0",	/* addrj: reg */
/* 167 */	"%0",	/* addrj: mem */
/* 168 */	"jmp %0\n",	/* stmt: JUMPV(addrj) */
/* 169 */	"%a:\n",	/* stmt: LABELV */
/* 170 */	"cmp %0,%1\nje %a\n",	/* stmt: EQI(mem,rc) */
/* 171 */	"cmp %0,%1\njge %a\n",	/* stmt: GEI(mem,rc) */
/* 172 */	"cmp %0,%1\njg %a\n",	/* stmt: GTI(mem,rc) */
/* 173 */	"cmp %0,%1\njle %a\n",	/* stmt: LEI(mem,rc) */
/* 174 */	"cmp %0,%1\njl %a\n",	/* stmt: LTI(mem,rc) */
/* 175 */	"cmp %0,%1\njne %a\n",	/* stmt: NEI(mem,rc) */
/* 176 */	"cmp %0,%1\njae %a\n",	/* stmt: GEU(mem,rc) */
/* 177 */	"cmp %0,%1\nja  %a\n",	/* stmt: GTU(mem,rc) */
/* 178 */	"cmp %0,%1\njbe %a\n",	/* stmt: LEU(mem,rc) */
/* 179 */	"cmp %0,%1\njb  %a\n",	/* stmt: LTU(mem,rc) */
/* 180 */	"cmp %0,%1\nje %a\n",	/* stmt: EQI(reg,mrc1) */
/* 181 */	"cmp %0,%1\njge %a\n",	/* stmt: GEI(reg,mrc1) */
/* 182 */	"cmp %0,%1\njg %a\n",	/* stmt: GTI(reg,mrc1) */
/* 183 */	"cmp %0,%1\njle %a\n",	/* stmt: LEI(reg,mrc1) */
/* 184 */	"cmp %0,%1\njl %a\n",	/* stmt: LTI(reg,mrc1) */
/* 185 */	"cmp %0,%1\njne %a\n",	/* stmt: NEI(reg,mrc1) */
/* 186 */	"cmp %0,%1\njae %a\n",	/* stmt: GEU(reg,mrc1) */
/* 187 */	"cmp %0,%1\nja %a\n",	/* stmt: GTU(reg,mrc1) */
/* 188 */	"cmp %0,%1\njbe %a\n",	/* stmt: LEU(reg,mrc1) */
/* 189 */	"cmp %0,%1\njb %a\n",	/* stmt: LTU(reg,mrc1) */
/* 190 */	" %0",	/* cmpf: memf */
/* 191 */	"p",	/* cmpf: reg */
/* 192 */	"fcomp%0\nfstsw ax\nsahf\nje %a\n",	/* stmt: EQD(cmpf,reg) */
/* 193 */	"fcomp%0\nfstsw ax\nsahf\njbe %a\n",	/* stmt: GED(cmpf,reg) */
/* 194 */	"fcomp%0\nfstsw ax\nsahf\njb %a\n",	/* stmt: GTD(cmpf,reg) */
/* 195 */	"fcomp%0\nfstsw ax\nsahf\njae %a\n",	/* stmt: LED(cmpf,reg) */
/* 196 */	"fcomp%0\nfstsw ax\nsahf\nja %a\n",	/* stmt: LTD(cmpf,reg) */
/* 197 */	"fcomp%0\nfstsw ax\nsahf\njne %a\n",	/* stmt: NED(cmpf,reg) */
/* 198 */	"fcomp%0\nfstsw ax\nsahf\nje %a\n",	/* stmt: EQF(cmpf,reg) */
/* 199 */	"fcomp%0\nfstsw ax\nsahf\njbe %a\n",	/* stmt: GEF(cmpf,reg) */
/* 200 */	"fcomp%0\nfstsw ax\nsahf\njb %a\n",	/* stmt: GTF(cmpf,reg) */
/* 201 */	"fcomp%0\nfstsw ax\nsahf\njae %a\n",	/* stmt: LEF(cmpf,reg) */
/* 202 */	"fcomp%0\nfstsw ax\nsahf\nja %a\n",	/* stmt: LTF(cmpf,reg) */
/* 203 */	"fcomp%0\nfstsw ax\nsahf\njne %a\n",	/* stmt: NEF(cmpf,reg) */
/* 204 */	"call %0\nadd esp,%a\n",	/* reg: CALLI(addrj) */
/* 205 */	"call %0\nadd esp,%a\n",	/* stmt: CALLV(addrj) */
/* 206 */	"call %0\nadd esp,%a\n",	/* reg: CALLF(addrj) */
/* 207 */	"call %0\nadd esp,%a\n",	/* reg: CALLD(addrj) */
/* 208 */	"# ret\n",	/* stmt: RETI(reg) */
/* 209 */	"# ret\n",	/* stmt: RETF(reg) */
/* 210 */	"# ret\n",	/* stmt: RETD(reg) */
};

static char _isinstruction[] = {
/* 0 */	0,
/* 1 */	1,	/* # read register\n */
/* 2 */	1,	/* # read register\n */
/* 3 */	1,	/* # read register\n */
/* 4 */	1,	/* # read register\n */
/* 5 */	1,	/* # read register\n */
/* 6 */	1,	/* # read register\n */
/* 7 */	1,	/* # write register\n */
/* 8 */	1,	/* # write register\n */
/* 9 */	1,	/* # write register\n */
/* 10 */	1,	/* # write register\n */
/* 11 */	1,	/* # write register\n */
/* 12 */	1,	/* # write register\n */
/* 13 */	0,	/* %a */
/* 14 */	0,	/* %a */
/* 15 */	0,	/* %a */
/* 16 */	0,	/* %a */
/* 17 */	0,	/* %a */
/* 18 */	0,	/*  */
/* 19 */	0,	/* %0 */
/* 20 */	0,	/* %0 */
/* 21 */	0,	/* %0 */
/* 22 */	0,	/* %0 */
/* 23 */	0,	/* %a */
/* 24 */	0,	/* %0 */
/* 25 */	0,	/* %a */
/* 26 */	0,	/* [%0] */
/* 27 */	0,	/* %1[%0] */
/* 28 */	0,	/* %1[%0] */
/* 29 */	0,	/* %1[%0] */
/* 30 */	0,	/* %a[ebp] */
/* 31 */	0,	/* %a[ebp] */
/* 32 */	0,	/* %0 */
/* 33 */	0,	/* %0*2 */
/* 34 */	0,	/* %0*4 */
/* 35 */	0,	/* %0*8 */
/* 36 */	0,	/* 1 */
/* 37 */	0,	/* 1 */
/* 38 */	0,	/* 2 */
/* 39 */	0,	/* 2 */
/* 40 */	0,	/* 3 */
/* 41 */	0,	/* 3 */
/* 42 */	0,	/* %0*2 */
/* 43 */	0,	/* %0*4 */
/* 44 */	0,	/* %0*8 */
/* 45 */	0,	/* %0 */
/* 46 */	0,	/* %1[%0] */
/* 47 */	0,	/* %1[%0] */
/* 48 */	0,	/* %1[%0] */
/* 49 */	0,	/* [%0] */
/* 50 */	0,	/* byte ptr %0 */
/* 51 */	0,	/* dword ptr %0 */
/* 52 */	0,	/* dword ptr %0 */
/* 53 */	0,	/* word ptr %0 */
/* 54 */	0,	/* %0 */
/* 55 */	0,	/* %0 */
/* 56 */	0,	/* %0 */
/* 57 */	0,	/* %0 */
/* 58 */	0,	/* %0 */
/* 59 */	0,	/* %0 */
/* 60 */	0,	/* %0 */
/* 61 */	0,	/* %0 */
/* 62 */	0,	/* %0 */
/* 63 */	0,	/* %0 */
/* 64 */	1,	/* lea %c,%0\n */
/* 65 */	1,	/* mov %c,%0\n */
/* 66 */	1,	/* mov %c,%0\n */
/* 67 */	1,	/* mov %c,%0\n */
/* 68 */	1,	/* mov %c,%0\n */
/* 69 */	1,	/* mov %c,%0\n */
/* 70 */	1,	/* mov %c,%0\n */
/* 71 */	1,	/* ?mov %c,%0\nadd %c,%1\n */
/* 72 */	1,	/* ?mov %c,%0\nadd %c,%1\n */
/* 73 */	1,	/* ?mov %c,%0\nadd %c,%1\n */
/* 74 */	1,	/* ?mov %c,%0\nsub %c,%1\n */
/* 75 */	1,	/* ?mov %c,%0\nsub %c,%1\n */
/* 76 */	1,	/* ?mov %c,%0\nsub %c,%1\n */
/* 77 */	1,	/* ?mov %c,%0\nand %c,%1\n */
/* 78 */	1,	/* ?mov %c,%0\nor %c,%1\n */
/* 79 */	1,	/* ?mov %c,%0\nxor %c,%1\n */
/* 80 */	1,	/* inc %1\n */
/* 81 */	1,	/* inc %1\n */
/* 82 */	1,	/* inc %1\n */
/* 83 */	1,	/* dec %1\n */
/* 84 */	1,	/* dec %1\n */
/* 85 */	1,	/* dec %1\n */
/* 86 */	1,	/* add %1,%2\n */
/* 87 */	1,	/* add %1,%2\n */
/* 88 */	1,	/* sub %1,%2\n */
/* 89 */	1,	/* sub %1,%2\n */
/* 90 */	1,	/* and %1,%2\n */
/* 91 */	1,	/* or %1,%2\n */
/* 92 */	1,	/* xor %1,%2\n */
/* 93 */	1,	/* ?mov %c,%0\nnot %c\n */
/* 94 */	1,	/* ?mov %c,%0\nneg %c\n */
/* 95 */	1,	/* not %1\n */
/* 96 */	1,	/* neg %1\n */
/* 97 */	1,	/* ?mov %c,%0\nsal %c,%1\n */
/* 98 */	1,	/* ?mov %c,%0\nshl %c,%1\n */
/* 99 */	1,	/* ?mov %c,%0\nsar %c,%1\n */
/* 100 */	1,	/* ?mov %c,%0\nshr %c,%1\n */
/* 101 */	1,	/* sal %1,%2\n */
/* 102 */	1,	/* shl %1,%2\n */
/* 103 */	1,	/* sar %1,%2\n */
/* 104 */	1,	/* shr %1,%2\n */
/* 105 */	0,	/* %a */
/* 106 */	0,	/* cl */
/* 107 */	1,	/* ?mov %c,%0\nimul %c,%1\n */
/* 108 */	1,	/* imul %c,%1,%0\n */
/* 109 */	1,	/* mul %1\n */
/* 110 */	1,	/* xor edx,edx\ndiv %1\n */
/* 111 */	1,	/* xor edx,edx\ndiv %1\n */
/* 112 */	1,	/* cdq\nidiv %1\n */
/* 113 */	1,	/* cdq\nidiv %1\n */
/* 114 */	1,	/* mov %c,%0\n */
/* 115 */	1,	/* mov %c,%0\n */
/* 116 */	1,	/* mov %c,%0\n */
/* 117 */	1,	/* mov %c,%0\n */
/* 118 */	1,	/* movsx %c,byte ptr %0\n */
/* 119 */	1,	/* movzx %c,byte ptr %0\n */
/* 120 */	1,	/* movsx %c,word ptr %0\n */
/* 121 */	1,	/* movzx %c,word ptr %0\n */
/* 122 */	1,	/* # extend\n */
/* 123 */	1,	/* # extend\n */
/* 124 */	1,	/* # extend\n */
/* 125 */	1,	/* # extend\n */
/* 126 */	1,	/* # truncate\n */
/* 127 */	1,	/* # truncate\n */
/* 128 */	1,	/* # truncate\n */
/* 129 */	1,	/* # truncate\n */
/* 130 */	1,	/* mov byte ptr %0,%1\n */
/* 131 */	1,	/* mov dword ptr %0,%1\n */
/* 132 */	1,	/* mov dword ptr %0,%1\n */
/* 133 */	1,	/* mov word ptr %0,%1\n */
/* 134 */	1,	/* push %0\n */
/* 135 */	1,	/* push %0\n */
/* 136 */	1,	/* mov ecx,%a\nrep movsb\n */
/* 137 */	1,	/* sub esp,%a\nmov edi,esp\nmov ecx,%a\nrep movsb\n */
/* 138 */	0,	/* qword ptr %0 */
/* 139 */	0,	/* dword ptr %0 */
/* 140 */	0,	/* dword ptr %0 */
/* 141 */	1,	/* fld %0\n */
/* 142 */	1,	/* fstp qword ptr %0\n */
/* 143 */	1,	/* fstp dword ptr %0\n */
/* 144 */	1,	/* fstp dword ptr %0\n */
/* 145 */	1,	/* sub esp,8\nfstp qword ptr [esp]\n */
/* 146 */	1,	/* sub esp,4\nfstp dword ptr [esp]\n */
/* 147 */	1,	/* fchs\n */
/* 148 */	1,	/* fchs\n */
/* 149 */	0,	/*  %0 */
/* 150 */	0,	/* p st(1),st */
/* 151 */	1,	/* fadd%1\n */
/* 152 */	1,	/* fadd%1\n */
/* 153 */	1,	/* fdiv%1\n */
/* 154 */	1,	/* fdiv%1\n */
/* 155 */	1,	/* fmul%1\n */
/* 156 */	1,	/* fmul%1\n */
/* 157 */	1,	/* fsub%1\n */
/* 158 */	1,	/* fsub%1\n */
/* 159 */	1,	/* # CVFD\n */
/* 160 */	1,	/* sub esp,4\nfstp dword ptr 0[esp]\nfld dword ptr 0[esp]\nadd esp,4\n */
/* 161 */	1,	/* fistp dword ptr %0\n */
/* 162 */	1,	/* sub esp,4\nfistp dword ptr 0[esp]\npop %c\n */
/* 163 */	1,	/* fild dword ptr %0\n */
/* 164 */	1,	/* push %0\nfild dword ptr 0[esp]\nadd esp,4\n */
/* 165 */	0,	/* %a */
/* 166 */	0,	/* %0 */
/* 167 */	0,	/* %0 */
/* 168 */	1,	/* jmp %0\n */
/* 169 */	1,	/* %a:\n */
/* 170 */	1,	/* cmp %0,%1\nje %a\n */
/* 171 */	1,	/* cmp %0,%1\njge %a\n */
/* 172 */	1,	/* cmp %0,%1\njg %a\n */
/* 173 */	1,	/* cmp %0,%1\njle %a\n */
/* 174 */	1,	/* cmp %0,%1\njl %a\n */
/* 175 */	1,	/* cmp %0,%1\njne %a\n */
/* 176 */	1,	/* cmp %0,%1\njae %a\n */
/* 177 */	1,	/* cmp %0,%1\nja  %a\n */
/* 178 */	1,	/* cmp %0,%1\njbe %a\n */
/* 179 */	1,	/* cmp %0,%1\njb  %a\n */
/* 180 */	1,	/* cmp %0,%1\nje %a\n */
/* 181 */	1,	/* cmp %0,%1\njge %a\n */
/* 182 */	1,	/* cmp %0,%1\njg %a\n */
/* 183 */	1,	/* cmp %0,%1\njle %a\n */
/* 184 */	1,	/* cmp %0,%1\njl %a\n */
/* 185 */	1,	/* cmp %0,%1\njne %a\n */
/* 186 */	1,	/* cmp %0,%1\njae %a\n */
/* 187 */	1,	/* cmp %0,%1\nja %a\n */
/* 188 */	1,	/* cmp %0,%1\njbe %a\n */
/* 189 */	1,	/* cmp %0,%1\njb %a\n */
/* 190 */	0,	/*  %0 */
/* 191 */	0,	/* p */
/* 192 */	1,	/* fcomp%0\nfstsw ax\nsahf\nje %a\n */
/* 193 */	1,	/* fcomp%0\nfstsw ax\nsahf\njbe %a\n */
/* 194 */	1,	/* fcomp%0\nfstsw ax\nsahf\njb %a\n */
/* 195 */	1,	/* fcomp%0\nfstsw ax\nsahf\njae %a\n */
/* 196 */	1,	/* fcomp%0\nfstsw ax\nsahf\nja %a\n */
/* 197 */	1,	/* fcomp%0\nfstsw ax\nsahf\njne %a\n */
/* 198 */	1,	/* fcomp%0\nfstsw ax\nsahf\nje %a\n */
/* 199 */	1,	/* fcomp%0\nfstsw ax\nsahf\njbe %a\n */
/* 200 */	1,	/* fcomp%0\nfstsw ax\nsahf\njb %a\n */
/* 201 */	1,	/* fcomp%0\nfstsw ax\nsahf\njae %a\n */
/* 202 */	1,	/* fcomp%0\nfstsw ax\nsahf\nja %a\n */
/* 203 */	1,	/* fcomp%0\nfstsw ax\nsahf\njne %a\n */
/* 204 */	1,	/* call %0\nadd esp,%a\n */
/* 205 */	1,	/* call %0\nadd esp,%a\n */
/* 206 */	1,	/* call %0\nadd esp,%a\n */
/* 207 */	1,	/* call %0\nadd esp,%a\n */
/* 208 */	1,	/* # ret\n */
/* 209 */	1,	/* # ret\n */
/* 210 */	1,	/* # ret\n */
};

static char *_string[] = {
/* 0 */	0,
/* 1 */	"reg: INDIRC(VREGP)",
/* 2 */	"reg: INDIRD(VREGP)",
/* 3 */	"reg: INDIRF(VREGP)",
/* 4 */	"reg: INDIRI(VREGP)",
/* 5 */	"reg: INDIRP(VREGP)",
/* 6 */	"reg: INDIRS(VREGP)",
/* 7 */	"stmt: ASGNC(VREGP,reg)",
/* 8 */	"stmt: ASGND(VREGP,reg)",
/* 9 */	"stmt: ASGNF(VREGP,reg)",
/* 10 */	"stmt: ASGNI(VREGP,reg)",
/* 11 */	"stmt: ASGNP(VREGP,reg)",
/* 12 */	"stmt: ASGNS(VREGP,reg)",
/* 13 */	"con: CNSTC",
/* 14 */	"con: CNSTI",
/* 15 */	"con: CNSTP",
/* 16 */	"con: CNSTS",
/* 17 */	"con: CNSTU",
/* 18 */	"stmt: reg",
/* 19 */	"reg: CVIU(reg)",
/* 20 */	"reg: CVPU(reg)",
/* 21 */	"reg: CVUI(reg)",
/* 22 */	"reg: CVUP(reg)",
/* 23 */	"acon: ADDRGP",
/* 24 */	"acon: con",
/* 25 */	"base: ADDRGP",
/* 26 */	"base: reg",
/* 27 */	"base: ADDI(reg,acon)",
/* 28 */	"base: ADDP(reg,acon)",
/* 29 */	"base: ADDU(reg,acon)",
/* 30 */	"base: ADDRFP",
/* 31 */	"base: ADDRLP",
/* 32 */	"index: reg",
/* 33 */	"index: LSHI(reg,con1)",
/* 34 */	"index: LSHI(reg,con2)",
/* 35 */	"index: LSHI(reg,con3)",
/* 36 */	"con1: CNSTI",
/* 37 */	"con1: CNSTU",
/* 38 */	"con2: CNSTI",
/* 39 */	"con2: CNSTU",
/* 40 */	"con3: CNSTI",
/* 41 */	"con3: CNSTU",
/* 42 */	"index: LSHU(reg,con1)",
/* 43 */	"index: LSHU(reg,con2)",
/* 44 */	"index: LSHU(reg,con3)",
/* 45 */	"addr: base",
/* 46 */	"addr: ADDI(index,base)",
/* 47 */	"addr: ADDP(index,base)",
/* 48 */	"addr: ADDU(index,base)",
/* 49 */	"addr: index",
/* 50 */	"mem: INDIRC(addr)",
/* 51 */	"mem: INDIRI(addr)",
/* 52 */	"mem: INDIRP(addr)",
/* 53 */	"mem: INDIRS(addr)",
/* 54 */	"rc: reg",
/* 55 */	"rc: con",
/* 56 */	"mr: reg",
/* 57 */	"mr: mem",
/* 58 */	"mrc0: mem",
/* 59 */	"mrc0: rc",
/* 60 */	"mrc1: mem",
/* 61 */	"mrc1: rc",
/* 62 */	"mrc3: mem",
/* 63 */	"mrc3: rc",
/* 64 */	"reg: addr",
/* 65 */	"reg: mrc0",
/* 66 */	"reg: LOADC(reg)",
/* 67 */	"reg: LOADI(reg)",
/* 68 */	"reg: LOADP(reg)",
/* 69 */	"reg: LOADS(reg)",
/* 70 */	"reg: LOADU(reg)",
/* 71 */	"reg: ADDI(reg,mrc1)",
/* 72 */	"reg: ADDP(reg,mrc1)",
/* 73 */	"reg: ADDU(reg,mrc1)",
/* 74 */	"reg: SUBI(reg,mrc1)",
/* 75 */	"reg: SUBP(reg,mrc1)",
/* 76 */	"reg: SUBU(reg,mrc1)",
/* 77 */	"reg: BANDU(reg,mrc1)",
/* 78 */	"reg: BORU(reg,mrc1)",
/* 79 */	"reg: BXORU(reg,mrc1)",
/* 80 */	"stmt: ASGNI(addr,ADDI(mem,con1))",
/* 81 */	"stmt: ASGNI(addr,ADDU(mem,con1))",
/* 82 */	"stmt: ASGNP(addr,ADDP(mem,con1))",
/* 83 */	"stmt: ASGNI(addr,SUBI(mem,con1))",
/* 84 */	"stmt: ASGNI(addr,SUBU(mem,con1))",
/* 85 */	"stmt: ASGNP(addr,SUBP(mem,con1))",
/* 86 */	"stmt: ASGNI(addr,ADDI(mem,rc))",
/* 87 */	"stmt: ASGNI(addr,ADDU(mem,rc))",
/* 88 */	"stmt: ASGNI(addr,SUBI(mem,rc))",
/* 89 */	"stmt: ASGNI(addr,SUBU(mem,rc))",
/* 90 */	"stmt: ASGNI(addr,BANDU(mem,rc))",
/* 91 */	"stmt: ASGNI(addr,BORU(mem,rc))",
/* 92 */	"stmt: ASGNI(addr,BXORU(mem,rc))",
/* 93 */	"reg: BCOMU(reg)",
/* 94 */	"reg: NEGI(reg)",
/* 95 */	"stmt: ASGNI(addr,BCOMU(mem))",
/* 96 */	"stmt: ASGNI(addr,NEGI(mem))",
/* 97 */	"reg: LSHI(reg,rc5)",
/* 98 */	"reg: LSHU(reg,rc5)",
/* 99 */	"reg: RSHI(reg,rc5)",
/* 100 */	"reg: RSHU(reg,rc5)",
/* 101 */	"stmt: ASGNI(addr,LSHI(mem,rc5))",
/* 102 */	"stmt: ASGNI(addr,LSHU(mem,rc5))",
/* 103 */	"stmt: ASGNI(addr,RSHI(mem,rc5))",
/* 104 */	"stmt: ASGNI(addr,RSHU(mem,rc5))",
/* 105 */	"rc5: CNSTI",
/* 106 */	"rc5: reg",
/* 107 */	"reg: MULI(reg,mrc3)",
/* 108 */	"reg: MULI(con,mr)",
/* 109 */	"reg: MULU(reg,mr)",
/* 110 */	"reg: DIVU(reg,reg)",
/* 111 */	"reg: MODU(reg,reg)",
/* 112 */	"reg: DIVI(reg,reg)",
/* 113 */	"reg: MODI(reg,reg)",
/* 114 */	"reg: CVIU(reg)",
/* 115 */	"reg: CVPU(reg)",
/* 116 */	"reg: CVUI(reg)",
/* 117 */	"reg: CVUP(reg)",
/* 118 */	"reg: CVCI(INDIRC(addr))",
/* 119 */	"reg: CVCU(INDIRC(addr))",
/* 120 */	"reg: CVSI(INDIRS(addr))",
/* 121 */	"reg: CVSU(INDIRS(addr))",
/* 122 */	"reg: CVCI(reg)",
/* 123 */	"reg: CVCU(reg)",
/* 124 */	"reg: CVSI(reg)",
/* 125 */	"reg: CVSU(reg)",
/* 126 */	"reg: CVIC(reg)",
/* 127 */	"reg: CVIS(reg)",
/* 128 */	"reg: CVUC(reg)",
/* 129 */	"reg: CVUS(reg)",
/* 130 */	"stmt: ASGNC(addr,rc)",
/* 131 */	"stmt: ASGNI(addr,rc)",
/* 132 */	"stmt: ASGNP(addr,rc)",
/* 133 */	"stmt: ASGNS(addr,rc)",
/* 134 */	"stmt: ARGI(mrc3)",
/* 135 */	"stmt: ARGP(mrc3)",
/* 136 */	"stmt: ASGNB(reg,INDIRB(reg))",
/* 137 */	"stmt: ARGB(INDIRB(reg))",
/* 138 */	"memf: INDIRD(addr)",
/* 139 */	"memf: INDIRF(addr)",
/* 140 */	"memf: CVFD(INDIRF(addr))",
/* 141 */	"reg: memf",
/* 142 */	"stmt: ASGND(addr,reg)",
/* 143 */	"stmt: ASGNF(addr,reg)",
/* 144 */	"stmt: ASGNF(addr,CVDF(reg))",
/* 145 */	"stmt: ARGD(reg)",
/* 146 */	"stmt: ARGF(reg)",
/* 147 */	"reg: NEGD(reg)",
/* 148 */	"reg: NEGF(reg)",
/* 149 */	"flt: memf",
/* 150 */	"flt: reg",
/* 151 */	"reg: ADDD(reg,flt)",
/* 152 */	"reg: ADDF(reg,flt)",
/* 153 */	"reg: DIVD(reg,flt)",
/* 154 */	"reg: DIVF(reg,flt)",
/* 155 */	"reg: MULD(reg,flt)",
/* 156 */	"reg: MULF(reg,flt)",
/* 157 */	"reg: SUBD(reg,flt)",
/* 158 */	"reg: SUBF(reg,flt)",
/* 159 */	"reg: CVFD(reg)",
/* 160 */	"reg: CVDF(reg)",
/* 161 */	"stmt: ASGNI(addr,CVDI(reg))",
/* 162 */	"reg: CVDI(reg)",
/* 163 */	"reg: CVID(INDIRI(addr))",
/* 164 */	"reg: CVID(reg)",
/* 165 */	"addrj: ADDRGP",
/* 166 */	"addrj: reg",
/* 167 */	"addrj: mem",
/* 168 */	"stmt: JUMPV(addrj)",
/* 169 */	"stmt: LABELV",
/* 170 */	"stmt: EQI(mem,rc)",
/* 171 */	"stmt: GEI(mem,rc)",
/* 172 */	"stmt: GTI(mem,rc)",
/* 173 */	"stmt: LEI(mem,rc)",
/* 174 */	"stmt: LTI(mem,rc)",
/* 175 */	"stmt: NEI(mem,rc)",
/* 176 */	"stmt: GEU(mem,rc)",
/* 177 */	"stmt: GTU(mem,rc)",
/* 178 */	"stmt: LEU(mem,rc)",
/* 179 */	"stmt: LTU(mem,rc)",
/* 180 */	"stmt: EQI(reg,mrc1)",
/* 181 */	"stmt: GEI(reg,mrc1)",
/* 182 */	"stmt: GTI(reg,mrc1)",
/* 183 */	"stmt: LEI(reg,mrc1)",
/* 184 */	"stmt: LTI(reg,mrc1)",
/* 185 */	"stmt: NEI(reg,mrc1)",
/* 186 */	"stmt: GEU(reg,mrc1)",
/* 187 */	"stmt: GTU(reg,mrc1)",
/* 188 */	"stmt: LEU(reg,mrc1)",
/* 189 */	"stmt: LTU(reg,mrc1)",
/* 190 */	"cmpf: memf",
/* 191 */	"cmpf: reg",
/* 192 */	"stmt: EQD(cmpf,reg)",
/* 193 */	"stmt: GED(cmpf,reg)",
/* 194 */	"stmt: GTD(cmpf,reg)",
/* 195 */	"stmt: LED(cmpf,reg)",
/* 196 */	"stmt: LTD(cmpf,reg)",
/* 197 */	"stmt: NED(cmpf,reg)",
/* 198 */	"stmt: EQF(cmpf,reg)",
/* 199 */	"stmt: GEF(cmpf,reg)",
/* 200 */	"stmt: GTF(cmpf,reg)",
/* 201 */	"stmt: LEF(cmpf,reg)",
/* 202 */	"stmt: LTF(cmpf,reg)",
/* 203 */	"stmt: NEF(cmpf,reg)",
/* 204 */	"reg: CALLI(addrj)",
/* 205 */	"stmt: CALLV(addrj)",
/* 206 */	"reg: CALLF(addrj)",
/* 207 */	"reg: CALLD(addrj)",
/* 208 */	"stmt: RETI(reg)",
/* 209 */	"stmt: RETF(reg)",
/* 210 */	"stmt: RETD(reg)",
};

static short _decode_stmt[] = {
	0,
	7,
	8,
	9,
	10,
	11,
	12,
	18,
	80,
	81,
	82,
	83,
	84,
	85,
	86,
	87,
	88,
	89,
	90,
	91,
	92,
	95,
	96,
	101,
	102,
	103,
	104,
	130,
	131,
	132,
	133,
	134,
	135,
	136,
	137,
	142,
	143,
	144,
	145,
	146,
	161,
	168,
	169,
	170,
	171,
	172,
	173,
	174,
	175,
	176,
	177,
	178,
	179,
	180,
	181,
	182,
	183,
	184,
	185,
	186,
	187,
	188,
	189,
	192,
	193,
	194,
	195,
	196,
	197,
	198,
	199,
	200,
	201,
	202,
	203,
	205,
	208,
	209,
	210,
};

static short _decode_reg[] = {
	0,
	1,
	2,
	3,
	4,
	5,
	6,
	19,
	20,
	21,
	22,
	64,
	65,
	66,
	67,
	68,
	69,
	70,
	71,
	72,
	73,
	74,
	75,
	76,
	77,
	78,
	79,
	93,
	94,
	97,
	98,
	99,
	100,
	107,
	108,
	109,
	110,
	111,
	112,
	113,
	114,
	115,
	116,
	117,
	118,
	119,
	120,
	121,
	122,
	123,
	124,
	125,
	126,
	127,
	128,
	129,
	141,
	147,
	148,
	151,
	152,
	153,
	154,
	155,
	156,
	157,
	158,
	159,
	160,
	162,
	163,
	164,
	204,
	206,
	207,
};

static short _decode_con[] = {
	0,
	13,
	14,
	15,
	16,
	17,
};

static short _decode_acon[] = {
	0,
	23,
	24,
};

static short _decode_base[] = {
	0,
	25,
	26,
	27,
	28,
	29,
	30,
	31,
};

static short _decode_index[] = {
	0,
	32,
	33,
	34,
	35,
	42,
	43,
	44,
};

static short _decode_con1[] = {
	0,
	36,
	37,
};

static short _decode_con2[] = {
	0,
	38,
	39,
};

static short _decode_con3[] = {
	0,
	40,
	41,
};

static short _decode_addr[] = {
	0,
	45,
	46,
	47,
	48,
	49,
};

static short _decode_mem[] = {
	0,
	50,
	51,
	52,
	53,
};

static short _decode_rc[] = {
	0,
	54,
	55,
};

static short _decode_mr[] = {
	0,
	56,
	57,
};

static short _decode_mrc0[] = {
	0,
	58,
	59,
};

static short _decode_mrc1[] = {
	0,
	60,
	61,
};

static short _decode_mrc3[] = {
	0,
	62,
	63,
};

static short _decode_rc5[] = {
	0,
	105,
	106,
};

static short _decode_memf[] = {
	0,
	138,
	139,
	140,
};

static short _decode_flt[] = {
	0,
	149,
	150,
};

static short _decode_addrj[] = {
	0,
	165,
	166,
	167,
};

static short _decode_cmpf[] = {
	0,
	190,
	191,
};

static int _rule(state, goalnt) void *state; int goalnt; {
	if (goalnt < 1 || goalnt > 21)
		fatal("_rule", "Bad goal nonterminal %d\n", goalnt);
	if (!state)
		return 0;
	switch (goalnt) {
	case _stmt_NT:	return _decode_stmt[((struct _state *)state)->rule._stmt];
	case _reg_NT:	return _decode_reg[((struct _state *)state)->rule._reg];
	case _con_NT:	return _decode_con[((struct _state *)state)->rule._con];
	case _acon_NT:	return _decode_acon[((struct _state *)state)->rule._acon];
	case _base_NT:	return _decode_base[((struct _state *)state)->rule._base];
	case _index_NT:	return _decode_index[((struct _state *)state)->rule._index];
	case _con1_NT:	return _decode_con1[((struct _state *)state)->rule._con1];
	case _con2_NT:	return _decode_con2[((struct _state *)state)->rule._con2];
	case _con3_NT:	return _decode_con3[((struct _state *)state)->rule._con3];
	case _addr_NT:	return _decode_addr[((struct _state *)state)->rule._addr];
	case _mem_NT:	return _decode_mem[((struct _state *)state)->rule._mem];
	case _rc_NT:	return _decode_rc[((struct _state *)state)->rule._rc];
	case _mr_NT:	return _decode_mr[((struct _state *)state)->rule._mr];
	case _mrc0_NT:	return _decode_mrc0[((struct _state *)state)->rule._mrc0];
	case _mrc1_NT:	return _decode_mrc1[((struct _state *)state)->rule._mrc1];
	case _mrc3_NT:	return _decode_mrc3[((struct _state *)state)->rule._mrc3];
	case _rc5_NT:	return _decode_rc5[((struct _state *)state)->rule._rc5];
	case _memf_NT:	return _decode_memf[((struct _state *)state)->rule._memf];
	case _flt_NT:	return _decode_flt[((struct _state *)state)->rule._flt];
	case _addrj_NT:	return _decode_addrj[((struct _state *)state)->rule._addrj];
	case _cmpf_NT:	return _decode_cmpf[((struct _state *)state)->rule._cmpf];
	default:
		fatal("_rule", "Bad goal nonterminal %d\n", goalnt);
		return 0;
	}
}

static void _closure_reg ARGS((NODEPTR_TYPE, int));
static void _closure_con ARGS((NODEPTR_TYPE, int));
static void _closure_base ARGS((NODEPTR_TYPE, int));
static void _closure_index ARGS((NODEPTR_TYPE, int));
static void _closure_addr ARGS((NODEPTR_TYPE, int));
static void _closure_mem ARGS((NODEPTR_TYPE, int));
static void _closure_rc ARGS((NODEPTR_TYPE, int));
static void _closure_mrc0 ARGS((NODEPTR_TYPE, int));
static void _closure_memf ARGS((NODEPTR_TYPE, int));

static void _closure_reg(a, c) NODEPTR_TYPE a; int c; {
	struct _state *p = STATE_LABEL(a);
	if (c + 0 < p->cost[_cmpf_NT]) {
		p->cost[_cmpf_NT] = c + 0;
		p->rule._cmpf = 2;
	}
	if (c + 2 < p->cost[_addrj_NT]) {
		p->cost[_addrj_NT] = c + 2;
		p->rule._addrj = 2;
	}
	if (c + 0 < p->cost[_flt_NT]) {
		p->cost[_flt_NT] = c + 0;
		p->rule._flt = 2;
	}
	if (c + 0 < p->cost[_rc5_NT]) {
		p->cost[_rc5_NT] = c + 0;
		p->rule._rc5 = 2;
	}
	if (c + 0 < p->cost[_mr_NT]) {
		p->cost[_mr_NT] = c + 0;
		p->rule._mr = 1;
	}
	if (c + 0 < p->cost[_rc_NT]) {
		p->cost[_rc_NT] = c + 0;
		p->rule._rc = 1;
		_closure_rc(a, c + 0);
	}
	if (c + 0 < p->cost[_index_NT]) {
		p->cost[_index_NT] = c + 0;
		p->rule._index = 1;
		_closure_index(a, c + 0);
	}
	if (c + 0 < p->cost[_base_NT]) {
		p->cost[_base_NT] = c + 0;
		p->rule._base = 2;
		_closure_base(a, c + 0);
	}
	if (c + 0 < p->cost[_stmt_NT]) {
		p->cost[_stmt_NT] = c + 0;
		p->rule._stmt = 7;
	}
}

static void _closure_con(a, c) NODEPTR_TYPE a; int c; {
	struct _state *p = STATE_LABEL(a);
	if (c + 0 < p->cost[_rc_NT]) {
		p->cost[_rc_NT] = c + 0;
		p->rule._rc = 2;
		_closure_rc(a, c + 0);
	}
	if (c + 0 < p->cost[_acon_NT]) {
		p->cost[_acon_NT] = c + 0;
		p->rule._acon = 2;
	}
}

static void _closure_base(a, c) NODEPTR_TYPE a; int c; {
	struct _state *p = STATE_LABEL(a);
	if (c + 0 < p->cost[_addr_NT]) {
		p->cost[_addr_NT] = c + 0;
		p->rule._addr = 1;
		_closure_addr(a, c + 0);
	}
}

static void _closure_index(a, c) NODEPTR_TYPE a; int c; {
	struct _state *p = STATE_LABEL(a);
	if (c + 0 < p->cost[_addr_NT]) {
		p->cost[_addr_NT] = c + 0;
		p->rule._addr = 5;
		_closure_addr(a, c + 0);
	}
}

static void _closure_addr(a, c) NODEPTR_TYPE a; int c; {
	struct _state *p = STATE_LABEL(a);
	if (c + 1 < p->cost[_reg_NT]) {
		p->cost[_reg_NT] = c + 1;
		p->rule._reg = 11;
		_closure_reg(a, c + 1);
	}
}

static void _closure_mem(a, c) NODEPTR_TYPE a; int c; {
	struct _state *p = STATE_LABEL(a);
	if (c + 2 < p->cost[_addrj_NT]) {
		p->cost[_addrj_NT] = c + 2;
		p->rule._addrj = 3;
	}
	if (c + 3 < p->cost[_mrc3_NT]) {
		p->cost[_mrc3_NT] = c + 3;
		p->rule._mrc3 = 1;
	}
	if (c + 1 < p->cost[_mrc1_NT]) {
		p->cost[_mrc1_NT] = c + 1;
		p->rule._mrc1 = 1;
	}
	if (c + 0 < p->cost[_mrc0_NT]) {
		p->cost[_mrc0_NT] = c + 0;
		p->rule._mrc0 = 1;
		_closure_mrc0(a, c + 0);
	}
	if (c + 0 < p->cost[_mr_NT]) {
		p->cost[_mr_NT] = c + 0;
		p->rule._mr = 2;
	}
}

static void _closure_rc(a, c) NODEPTR_TYPE a; int c; {
	struct _state *p = STATE_LABEL(a);
	if (c + 0 < p->cost[_mrc3_NT]) {
		p->cost[_mrc3_NT] = c + 0;
		p->rule._mrc3 = 2;
	}
	if (c + 0 < p->cost[_mrc1_NT]) {
		p->cost[_mrc1_NT] = c + 0;
		p->rule._mrc1 = 2;
	}
	if (c + 0 < p->cost[_mrc0_NT]) {
		p->cost[_mrc0_NT] = c + 0;
		p->rule._mrc0 = 2;
		_closure_mrc0(a, c + 0);
	}
}

static void _closure_mrc0(a, c) NODEPTR_TYPE a; int c; {
	struct _state *p = STATE_LABEL(a);
	if (c + 1 < p->cost[_reg_NT]) {
		p->cost[_reg_NT] = c + 1;
		p->rule._reg = 12;
		_closure_reg(a, c + 1);
	}
}

static void _closure_memf(a, c) NODEPTR_TYPE a; int c; {
	struct _state *p = STATE_LABEL(a);
	if (c + 0 < p->cost[_cmpf_NT]) {
		p->cost[_cmpf_NT] = c + 0;
		p->rule._cmpf = 1;
	}
	if (c + 0 < p->cost[_flt_NT]) {
		p->cost[_flt_NT] = c + 0;
		p->rule._flt = 1;
	}
	if (c + 3 < p->cost[_reg_NT]) {
		p->cost[_reg_NT] = c + 3;
		p->rule._reg = 56;
		_closure_reg(a, c + 3);
	}
}

static void _label(a) NODEPTR_TYPE a; {
	int c;
	struct _state *p;

	if (!a)
		fatal("_label", "Null tree\n", 0);
	STATE_LABEL(a) = p = allocate(sizeof *p, FUNC);
	p->rule._stmt = 0;
	p->cost[1] =
	p->cost[2] =
	p->cost[3] =
	p->cost[4] =
	p->cost[5] =
	p->cost[6] =
	p->cost[7] =
	p->cost[8] =
	p->cost[9] =
	p->cost[10] =
	p->cost[11] =
	p->cost[12] =
	p->cost[13] =
	p->cost[14] =
	p->cost[15] =
	p->cost[16] =
	p->cost[17] =
	p->cost[18] =
	p->cost[19] =
	p->cost[20] =
	p->cost[21] =
		0x7fff;
	switch (OP_LABEL(a)) {
	case 17: /* CNSTF */
		break;
	case 18: /* CNSTD */
		break;
	case 19: /* CNSTC */
		/* con: CNSTC */
		if (0 + 0 < p->cost[_con_NT]) {
			p->cost[_con_NT] = 0 + 0;
			p->rule._con = 1;
			_closure_con(a, 0 + 0);
		}
		break;
	case 20: /* CNSTS */
		/* con: CNSTS */
		if (0 + 0 < p->cost[_con_NT]) {
			p->cost[_con_NT] = 0 + 0;
			p->rule._con = 4;
			_closure_con(a, 0 + 0);
		}
		break;
	case 21: /* CNSTI */
		/* con: CNSTI */
		if (0 + 0 < p->cost[_con_NT]) {
			p->cost[_con_NT] = 0 + 0;
			p->rule._con = 2;
			_closure_con(a, 0 + 0);
		}
		/* con1: CNSTI */
		c = (range(a, 1, 1));
		if (c + 0 < p->cost[_con1_NT]) {
			p->cost[_con1_NT] = c + 0;
			p->rule._con1 = 1;
		}
		/* con2: CNSTI */
		c = (range(a, 2, 2));
		if (c + 0 < p->cost[_con2_NT]) {
			p->cost[_con2_NT] = c + 0;
			p->rule._con2 = 1;
		}
		/* con3: CNSTI */
		c = (range(a, 3, 3));
		if (c + 0 < p->cost[_con3_NT]) {
			p->cost[_con3_NT] = c + 0;
			p->rule._con3 = 1;
		}
		/* rc5: CNSTI */
		c = (range(a, 0, 31));
		if (c + 0 < p->cost[_rc5_NT]) {
			p->cost[_rc5_NT] = c + 0;
			p->rule._rc5 = 1;
		}
		break;
	case 22: /* CNSTU */
		/* con: CNSTU */
		if (0 + 0 < p->cost[_con_NT]) {
			p->cost[_con_NT] = 0 + 0;
			p->rule._con = 5;
			_closure_con(a, 0 + 0);
		}
		/* con1: CNSTU */
		c = (range(a, 1, 1));
		if (c + 0 < p->cost[_con1_NT]) {
			p->cost[_con1_NT] = c + 0;
			p->rule._con1 = 2;
		}
		/* con2: CNSTU */
		c = (range(a, 2, 2));
		if (c + 0 < p->cost[_con2_NT]) {
			p->cost[_con2_NT] = c + 0;
			p->rule._con2 = 2;
		}
		/* con3: CNSTU */
		c = (range(a, 3, 3));
		if (c + 0 < p->cost[_con3_NT]) {
			p->cost[_con3_NT] = c + 0;
			p->rule._con3 = 2;
		}
		break;
	case 23: /* CNSTP */
		/* con: CNSTP */
		if (0 + 0 < p->cost[_con_NT]) {
			p->cost[_con_NT] = 0 + 0;
			p->rule._con = 3;
			_closure_con(a, 0 + 0);
		}
		break;
	case 33: /* ARGF */
		_label(LEFT_CHILD(a));
		/* stmt: ARGF(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 39;
		}
		break;
	case 34: /* ARGD */
		_label(LEFT_CHILD(a));
		/* stmt: ARGD(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 38;
		}
		break;
	case 37: /* ARGI */
		_label(LEFT_CHILD(a));
		/* stmt: ARGI(mrc3) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mrc3_NT] + 1;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 31;
		}
		break;
	case 39: /* ARGP */
		_label(LEFT_CHILD(a));
		/* stmt: ARGP(mrc3) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mrc3_NT] + 1;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 32;
		}
		break;
	case 41: /* ARGB */
		_label(LEFT_CHILD(a));
		if (	/* stmt: ARGB(INDIRB(reg)) */
			LEFT_CHILD(a)->op == 73 /* INDIRB */
		) {
			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_reg_NT] + 0;
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 34;
			}
		}
		break;
	case 49: /* ASGNF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		if (	/* stmt: ASGNF(VREGP,reg) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 3;
			}
		}
		/* stmt: ASGNF(addr,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 7;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 36;
		}
		if (	/* stmt: ASGNF(addr,CVDF(reg)) */
			RIGHT_CHILD(a)->op == 97 /* CVDF */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_reg_NT] + 7;
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 37;
			}
		}
		break;
	case 50: /* ASGND */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		if (	/* stmt: ASGND(VREGP,reg) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 2;
			}
		}
		/* stmt: ASGND(addr,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 7;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 35;
		}
		break;
	case 51: /* ASGNC */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		if (	/* stmt: ASGNC(VREGP,reg) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 1;
			}
		}
		/* stmt: ASGNC(addr,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 27;
		}
		break;
	case 52: /* ASGNS */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		if (	/* stmt: ASGNS(VREGP,reg) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 6;
			}
		}
		/* stmt: ASGNS(addr,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 30;
		}
		break;
	case 53: /* ASGNI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		if (	/* stmt: ASGNI(VREGP,reg) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 4;
			}
		}
		if (	/* stmt: ASGNI(addr,ADDI(mem,con1)) */
			RIGHT_CHILD(a)->op == 309 /* ADDI */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 8;
			}
		}
		if (	/* stmt: ASGNI(addr,ADDU(mem,con1)) */
			RIGHT_CHILD(a)->op == 310 /* ADDU */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 9;
			}
		}
		if (	/* stmt: ASGNI(addr,SUBI(mem,con1)) */
			RIGHT_CHILD(a)->op == 325 /* SUBI */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 11;
			}
		}
		if (	/* stmt: ASGNI(addr,SUBU(mem,con1)) */
			RIGHT_CHILD(a)->op == 326 /* SUBU */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 12;
			}
		}
		if (	/* stmt: ASGNI(addr,ADDI(mem,rc)) */
			RIGHT_CHILD(a)->op == 309 /* ADDI */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 14;
			}
		}
		if (	/* stmt: ASGNI(addr,ADDU(mem,rc)) */
			RIGHT_CHILD(a)->op == 310 /* ADDU */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 15;
			}
		}
		if (	/* stmt: ASGNI(addr,SUBI(mem,rc)) */
			RIGHT_CHILD(a)->op == 325 /* SUBI */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 16;
			}
		}
		if (	/* stmt: ASGNI(addr,SUBU(mem,rc)) */
			RIGHT_CHILD(a)->op == 326 /* SUBU */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 17;
			}
		}
		if (	/* stmt: ASGNI(addr,BANDU(mem,rc)) */
			RIGHT_CHILD(a)->op == 390 /* BANDU */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 18;
			}
		}
		if (	/* stmt: ASGNI(addr,BORU(mem,rc)) */
			RIGHT_CHILD(a)->op == 422 /* BORU */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 19;
			}
		}
		if (	/* stmt: ASGNI(addr,BXORU(mem,rc)) */
			RIGHT_CHILD(a)->op == 438 /* BXORU */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 20;
			}
		}
		if (	/* stmt: ASGNI(addr,BCOMU(mem)) */
			RIGHT_CHILD(a)->op == 406 /* BCOMU */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 21;
			}
		}
		if (	/* stmt: ASGNI(addr,NEGI(mem)) */
			RIGHT_CHILD(a)->op == 197 /* NEGI */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 22;
			}
		}
		if (	/* stmt: ASGNI(addr,LSHI(mem,rc5)) */
			RIGHT_CHILD(a)->op == 341 /* LSHI */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc5_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 23;
			}
		}
		if (	/* stmt: ASGNI(addr,LSHU(mem,rc5)) */
			RIGHT_CHILD(a)->op == 342 /* LSHU */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc5_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 24;
			}
		}
		if (	/* stmt: ASGNI(addr,RSHI(mem,rc5)) */
			RIGHT_CHILD(a)->op == 373 /* RSHI */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc5_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 25;
			}
		}
		if (	/* stmt: ASGNI(addr,RSHU(mem,rc5)) */
			RIGHT_CHILD(a)->op == 374 /* RSHU */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_rc5_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 26;
			}
		}
		/* stmt: ASGNI(addr,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 28;
		}
		if (	/* stmt: ASGNI(addr,CVDI(reg)) */
			RIGHT_CHILD(a)->op == 101 /* CVDI */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_reg_NT] + 29;
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 40;
			}
		}
		break;
	case 55: /* ASGNP */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		if (	/* stmt: ASGNP(VREGP,reg) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			c = ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 5;
			}
		}
		if (	/* stmt: ASGNP(addr,ADDP(mem,con1)) */
			RIGHT_CHILD(a)->op == 311 /* ADDP */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 10;
			}
		}
		if (	/* stmt: ASGNP(addr,SUBP(mem,con1)) */
			RIGHT_CHILD(a)->op == 327 /* SUBP */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_con1_NT] + (memop(a));
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 13;
			}
		}
		/* stmt: ASGNP(addr,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 1;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 29;
		}
		break;
	case 57: /* ASGNB */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		if (	/* stmt: ASGNB(reg,INDIRB(reg)) */
			RIGHT_CHILD(a)->op == 73 /* INDIRB */
		) {
			c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(LEFT_CHILD(RIGHT_CHILD(a))->x.state))->cost[_reg_NT] + 0;
			if (c + 0 < p->cost[_stmt_NT]) {
				p->cost[_stmt_NT] = c + 0;
				p->rule._stmt = 33;
			}
		}
		break;
	case 65: /* INDIRF */
		_label(LEFT_CHILD(a));
		if (	/* reg: INDIRF(VREGP) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			if (mayrecalc(a)) {
				struct _state *q = a->syms[RX]->u.t.cse->x.state;
				if (q->cost[_stmt_NT] == 0) {
					p->cost[_stmt_NT] = 0;
					p->rule._stmt = q->rule._stmt;
				}
				if (q->cost[_reg_NT] == 0) {
					p->cost[_reg_NT] = 0;
					p->rule._reg = q->rule._reg;
				}
				if (q->cost[_con_NT] == 0) {
					p->cost[_con_NT] = 0;
					p->rule._con = q->rule._con;
				}
				if (q->cost[_acon_NT] == 0) {
					p->cost[_acon_NT] = 0;
					p->rule._acon = q->rule._acon;
				}
				if (q->cost[_base_NT] == 0) {
					p->cost[_base_NT] = 0;
					p->rule._base = q->rule._base;
				}
				if (q->cost[_index_NT] == 0) {
					p->cost[_index_NT] = 0;
					p->rule._index = q->rule._index;
				}
				if (q->cost[_con1_NT] == 0) {
					p->cost[_con1_NT] = 0;
					p->rule._con1 = q->rule._con1;
				}
				if (q->cost[_con2_NT] == 0) {
					p->cost[_con2_NT] = 0;
					p->rule._con2 = q->rule._con2;
				}
				if (q->cost[_con3_NT] == 0) {
					p->cost[_con3_NT] = 0;
					p->rule._con3 = q->rule._con3;
				}
				if (q->cost[_addr_NT] == 0) {
					p->cost[_addr_NT] = 0;
					p->rule._addr = q->rule._addr;
				}
				if (q->cost[_mem_NT] == 0) {
					p->cost[_mem_NT] = 0;
					p->rule._mem = q->rule._mem;
				}
				if (q->cost[_rc_NT] == 0) {
					p->cost[_rc_NT] = 0;
					p->rule._rc = q->rule._rc;
				}
				if (q->cost[_mr_NT] == 0) {
					p->cost[_mr_NT] = 0;
					p->rule._mr = q->rule._mr;
				}
				if (q->cost[_mrc0_NT] == 0) {
					p->cost[_mrc0_NT] = 0;
					p->rule._mrc0 = q->rule._mrc0;
				}
				if (q->cost[_mrc1_NT] == 0) {
					p->cost[_mrc1_NT] = 0;
					p->rule._mrc1 = q->rule._mrc1;
				}
				if (q->cost[_mrc3_NT] == 0) {
					p->cost[_mrc3_NT] = 0;
					p->rule._mrc3 = q->rule._mrc3;
				}
				if (q->cost[_rc5_NT] == 0) {
					p->cost[_rc5_NT] = 0;
					p->rule._rc5 = q->rule._rc5;
				}
				if (q->cost[_memf_NT] == 0) {
					p->cost[_memf_NT] = 0;
					p->rule._memf = q->rule._memf;
				}
				if (q->cost[_flt_NT] == 0) {
					p->cost[_flt_NT] = 0;
					p->rule._flt = q->rule._flt;
				}
				if (q->cost[_addrj_NT] == 0) {
					p->cost[_addrj_NT] = 0;
					p->rule._addrj = q->rule._addrj;
				}
				if (q->cost[_cmpf_NT] == 0) {
					p->cost[_cmpf_NT] = 0;
					p->rule._cmpf = q->rule._cmpf;
				}
			}
			c = 0;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 3;
				_closure_reg(a, c + 0);
			}
		}
		/* memf: INDIRF(addr) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
		if (c + 0 < p->cost[_memf_NT]) {
			p->cost[_memf_NT] = c + 0;
			p->rule._memf = 2;
			_closure_memf(a, c + 0);
		}
		break;
	case 66: /* INDIRD */
		_label(LEFT_CHILD(a));
		if (	/* reg: INDIRD(VREGP) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			if (mayrecalc(a)) {
				struct _state *q = a->syms[RX]->u.t.cse->x.state;
				if (q->cost[_stmt_NT] == 0) {
					p->cost[_stmt_NT] = 0;
					p->rule._stmt = q->rule._stmt;
				}
				if (q->cost[_reg_NT] == 0) {
					p->cost[_reg_NT] = 0;
					p->rule._reg = q->rule._reg;
				}
				if (q->cost[_con_NT] == 0) {
					p->cost[_con_NT] = 0;
					p->rule._con = q->rule._con;
				}
				if (q->cost[_acon_NT] == 0) {
					p->cost[_acon_NT] = 0;
					p->rule._acon = q->rule._acon;
				}
				if (q->cost[_base_NT] == 0) {
					p->cost[_base_NT] = 0;
					p->rule._base = q->rule._base;
				}
				if (q->cost[_index_NT] == 0) {
					p->cost[_index_NT] = 0;
					p->rule._index = q->rule._index;
				}
				if (q->cost[_con1_NT] == 0) {
					p->cost[_con1_NT] = 0;
					p->rule._con1 = q->rule._con1;
				}
				if (q->cost[_con2_NT] == 0) {
					p->cost[_con2_NT] = 0;
					p->rule._con2 = q->rule._con2;
				}
				if (q->cost[_con3_NT] == 0) {
					p->cost[_con3_NT] = 0;
					p->rule._con3 = q->rule._con3;
				}
				if (q->cost[_addr_NT] == 0) {
					p->cost[_addr_NT] = 0;
					p->rule._addr = q->rule._addr;
				}
				if (q->cost[_mem_NT] == 0) {
					p->cost[_mem_NT] = 0;
					p->rule._mem = q->rule._mem;
				}
				if (q->cost[_rc_NT] == 0) {
					p->cost[_rc_NT] = 0;
					p->rule._rc = q->rule._rc;
				}
				if (q->cost[_mr_NT] == 0) {
					p->cost[_mr_NT] = 0;
					p->rule._mr = q->rule._mr;
				}
				if (q->cost[_mrc0_NT] == 0) {
					p->cost[_mrc0_NT] = 0;
					p->rule._mrc0 = q->rule._mrc0;
				}
				if (q->cost[_mrc1_NT] == 0) {
					p->cost[_mrc1_NT] = 0;
					p->rule._mrc1 = q->rule._mrc1;
				}
				if (q->cost[_mrc3_NT] == 0) {
					p->cost[_mrc3_NT] = 0;
					p->rule._mrc3 = q->rule._mrc3;
				}
				if (q->cost[_rc5_NT] == 0) {
					p->cost[_rc5_NT] = 0;
					p->rule._rc5 = q->rule._rc5;
				}
				if (q->cost[_memf_NT] == 0) {
					p->cost[_memf_NT] = 0;
					p->rule._memf = q->rule._memf;
				}
				if (q->cost[_flt_NT] == 0) {
					p->cost[_flt_NT] = 0;
					p->rule._flt = q->rule._flt;
				}
				if (q->cost[_addrj_NT] == 0) {
					p->cost[_addrj_NT] = 0;
					p->rule._addrj = q->rule._addrj;
				}
				if (q->cost[_cmpf_NT] == 0) {
					p->cost[_cmpf_NT] = 0;
					p->rule._cmpf = q->rule._cmpf;
				}
			}
			c = 0;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 2;
				_closure_reg(a, c + 0);
			}
		}
		/* memf: INDIRD(addr) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
		if (c + 0 < p->cost[_memf_NT]) {
			p->cost[_memf_NT] = c + 0;
			p->rule._memf = 1;
			_closure_memf(a, c + 0);
		}
		break;
	case 67: /* INDIRC */
		_label(LEFT_CHILD(a));
		if (	/* reg: INDIRC(VREGP) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			if (mayrecalc(a)) {
				struct _state *q = a->syms[RX]->u.t.cse->x.state;
				if (q->cost[_stmt_NT] == 0) {
					p->cost[_stmt_NT] = 0;
					p->rule._stmt = q->rule._stmt;
				}
				if (q->cost[_reg_NT] == 0) {
					p->cost[_reg_NT] = 0;
					p->rule._reg = q->rule._reg;
				}
				if (q->cost[_con_NT] == 0) {
					p->cost[_con_NT] = 0;
					p->rule._con = q->rule._con;
				}
				if (q->cost[_acon_NT] == 0) {
					p->cost[_acon_NT] = 0;
					p->rule._acon = q->rule._acon;
				}
				if (q->cost[_base_NT] == 0) {
					p->cost[_base_NT] = 0;
					p->rule._base = q->rule._base;
				}
				if (q->cost[_index_NT] == 0) {
					p->cost[_index_NT] = 0;
					p->rule._index = q->rule._index;
				}
				if (q->cost[_con1_NT] == 0) {
					p->cost[_con1_NT] = 0;
					p->rule._con1 = q->rule._con1;
				}
				if (q->cost[_con2_NT] == 0) {
					p->cost[_con2_NT] = 0;
					p->rule._con2 = q->rule._con2;
				}
				if (q->cost[_con3_NT] == 0) {
					p->cost[_con3_NT] = 0;
					p->rule._con3 = q->rule._con3;
				}
				if (q->cost[_addr_NT] == 0) {
					p->cost[_addr_NT] = 0;
					p->rule._addr = q->rule._addr;
				}
				if (q->cost[_mem_NT] == 0) {
					p->cost[_mem_NT] = 0;
					p->rule._mem = q->rule._mem;
				}
				if (q->cost[_rc_NT] == 0) {
					p->cost[_rc_NT] = 0;
					p->rule._rc = q->rule._rc;
				}
				if (q->cost[_mr_NT] == 0) {
					p->cost[_mr_NT] = 0;
					p->rule._mr = q->rule._mr;
				}
				if (q->cost[_mrc0_NT] == 0) {
					p->cost[_mrc0_NT] = 0;
					p->rule._mrc0 = q->rule._mrc0;
				}
				if (q->cost[_mrc1_NT] == 0) {
					p->cost[_mrc1_NT] = 0;
					p->rule._mrc1 = q->rule._mrc1;
				}
				if (q->cost[_mrc3_NT] == 0) {
					p->cost[_mrc3_NT] = 0;
					p->rule._mrc3 = q->rule._mrc3;
				}
				if (q->cost[_rc5_NT] == 0) {
					p->cost[_rc5_NT] = 0;
					p->rule._rc5 = q->rule._rc5;
				}
				if (q->cost[_memf_NT] == 0) {
					p->cost[_memf_NT] = 0;
					p->rule._memf = q->rule._memf;
				}
				if (q->cost[_flt_NT] == 0) {
					p->cost[_flt_NT] = 0;
					p->rule._flt = q->rule._flt;
				}
				if (q->cost[_addrj_NT] == 0) {
					p->cost[_addrj_NT] = 0;
					p->rule._addrj = q->rule._addrj;
				}
				if (q->cost[_cmpf_NT] == 0) {
					p->cost[_cmpf_NT] = 0;
					p->rule._cmpf = q->rule._cmpf;
				}
			}
			c = 0;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 1;
				_closure_reg(a, c + 0);
			}
		}
		/* mem: INDIRC(addr) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
		if (c + 0 < p->cost[_mem_NT]) {
			p->cost[_mem_NT] = c + 0;
			p->rule._mem = 1;
			_closure_mem(a, c + 0);
		}
		break;
	case 68: /* INDIRS */
		_label(LEFT_CHILD(a));
		if (	/* reg: INDIRS(VREGP) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			if (mayrecalc(a)) {
				struct _state *q = a->syms[RX]->u.t.cse->x.state;
				if (q->cost[_stmt_NT] == 0) {
					p->cost[_stmt_NT] = 0;
					p->rule._stmt = q->rule._stmt;
				}
				if (q->cost[_reg_NT] == 0) {
					p->cost[_reg_NT] = 0;
					p->rule._reg = q->rule._reg;
				}
				if (q->cost[_con_NT] == 0) {
					p->cost[_con_NT] = 0;
					p->rule._con = q->rule._con;
				}
				if (q->cost[_acon_NT] == 0) {
					p->cost[_acon_NT] = 0;
					p->rule._acon = q->rule._acon;
				}
				if (q->cost[_base_NT] == 0) {
					p->cost[_base_NT] = 0;
					p->rule._base = q->rule._base;
				}
				if (q->cost[_index_NT] == 0) {
					p->cost[_index_NT] = 0;
					p->rule._index = q->rule._index;
				}
				if (q->cost[_con1_NT] == 0) {
					p->cost[_con1_NT] = 0;
					p->rule._con1 = q->rule._con1;
				}
				if (q->cost[_con2_NT] == 0) {
					p->cost[_con2_NT] = 0;
					p->rule._con2 = q->rule._con2;
				}
				if (q->cost[_con3_NT] == 0) {
					p->cost[_con3_NT] = 0;
					p->rule._con3 = q->rule._con3;
				}
				if (q->cost[_addr_NT] == 0) {
					p->cost[_addr_NT] = 0;
					p->rule._addr = q->rule._addr;
				}
				if (q->cost[_mem_NT] == 0) {
					p->cost[_mem_NT] = 0;
					p->rule._mem = q->rule._mem;
				}
				if (q->cost[_rc_NT] == 0) {
					p->cost[_rc_NT] = 0;
					p->rule._rc = q->rule._rc;
				}
				if (q->cost[_mr_NT] == 0) {
					p->cost[_mr_NT] = 0;
					p->rule._mr = q->rule._mr;
				}
				if (q->cost[_mrc0_NT] == 0) {
					p->cost[_mrc0_NT] = 0;
					p->rule._mrc0 = q->rule._mrc0;
				}
				if (q->cost[_mrc1_NT] == 0) {
					p->cost[_mrc1_NT] = 0;
					p->rule._mrc1 = q->rule._mrc1;
				}
				if (q->cost[_mrc3_NT] == 0) {
					p->cost[_mrc3_NT] = 0;
					p->rule._mrc3 = q->rule._mrc3;
				}
				if (q->cost[_rc5_NT] == 0) {
					p->cost[_rc5_NT] = 0;
					p->rule._rc5 = q->rule._rc5;
				}
				if (q->cost[_memf_NT] == 0) {
					p->cost[_memf_NT] = 0;
					p->rule._memf = q->rule._memf;
				}
				if (q->cost[_flt_NT] == 0) {
					p->cost[_flt_NT] = 0;
					p->rule._flt = q->rule._flt;
				}
				if (q->cost[_addrj_NT] == 0) {
					p->cost[_addrj_NT] = 0;
					p->rule._addrj = q->rule._addrj;
				}
				if (q->cost[_cmpf_NT] == 0) {
					p->cost[_cmpf_NT] = 0;
					p->rule._cmpf = q->rule._cmpf;
				}
			}
			c = 0;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 6;
				_closure_reg(a, c + 0);
			}
		}
		/* mem: INDIRS(addr) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
		if (c + 0 < p->cost[_mem_NT]) {
			p->cost[_mem_NT] = c + 0;
			p->rule._mem = 4;
			_closure_mem(a, c + 0);
		}
		break;
	case 69: /* INDIRI */
		_label(LEFT_CHILD(a));
		if (	/* reg: INDIRI(VREGP) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			if (mayrecalc(a)) {
				struct _state *q = a->syms[RX]->u.t.cse->x.state;
				if (q->cost[_stmt_NT] == 0) {
					p->cost[_stmt_NT] = 0;
					p->rule._stmt = q->rule._stmt;
				}
				if (q->cost[_reg_NT] == 0) {
					p->cost[_reg_NT] = 0;
					p->rule._reg = q->rule._reg;
				}
				if (q->cost[_con_NT] == 0) {
					p->cost[_con_NT] = 0;
					p->rule._con = q->rule._con;
				}
				if (q->cost[_acon_NT] == 0) {
					p->cost[_acon_NT] = 0;
					p->rule._acon = q->rule._acon;
				}
				if (q->cost[_base_NT] == 0) {
					p->cost[_base_NT] = 0;
					p->rule._base = q->rule._base;
				}
				if (q->cost[_index_NT] == 0) {
					p->cost[_index_NT] = 0;
					p->rule._index = q->rule._index;
				}
				if (q->cost[_con1_NT] == 0) {
					p->cost[_con1_NT] = 0;
					p->rule._con1 = q->rule._con1;
				}
				if (q->cost[_con2_NT] == 0) {
					p->cost[_con2_NT] = 0;
					p->rule._con2 = q->rule._con2;
				}
				if (q->cost[_con3_NT] == 0) {
					p->cost[_con3_NT] = 0;
					p->rule._con3 = q->rule._con3;
				}
				if (q->cost[_addr_NT] == 0) {
					p->cost[_addr_NT] = 0;
					p->rule._addr = q->rule._addr;
				}
				if (q->cost[_mem_NT] == 0) {
					p->cost[_mem_NT] = 0;
					p->rule._mem = q->rule._mem;
				}
				if (q->cost[_rc_NT] == 0) {
					p->cost[_rc_NT] = 0;
					p->rule._rc = q->rule._rc;
				}
				if (q->cost[_mr_NT] == 0) {
					p->cost[_mr_NT] = 0;
					p->rule._mr = q->rule._mr;
				}
				if (q->cost[_mrc0_NT] == 0) {
					p->cost[_mrc0_NT] = 0;
					p->rule._mrc0 = q->rule._mrc0;
				}
				if (q->cost[_mrc1_NT] == 0) {
					p->cost[_mrc1_NT] = 0;
					p->rule._mrc1 = q->rule._mrc1;
				}
				if (q->cost[_mrc3_NT] == 0) {
					p->cost[_mrc3_NT] = 0;
					p->rule._mrc3 = q->rule._mrc3;
				}
				if (q->cost[_rc5_NT] == 0) {
					p->cost[_rc5_NT] = 0;
					p->rule._rc5 = q->rule._rc5;
				}
				if (q->cost[_memf_NT] == 0) {
					p->cost[_memf_NT] = 0;
					p->rule._memf = q->rule._memf;
				}
				if (q->cost[_flt_NT] == 0) {
					p->cost[_flt_NT] = 0;
					p->rule._flt = q->rule._flt;
				}
				if (q->cost[_addrj_NT] == 0) {
					p->cost[_addrj_NT] = 0;
					p->rule._addrj = q->rule._addrj;
				}
				if (q->cost[_cmpf_NT] == 0) {
					p->cost[_cmpf_NT] = 0;
					p->rule._cmpf = q->rule._cmpf;
				}
			}
			c = 0;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 4;
				_closure_reg(a, c + 0);
			}
		}
		/* mem: INDIRI(addr) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
		if (c + 0 < p->cost[_mem_NT]) {
			p->cost[_mem_NT] = c + 0;
			p->rule._mem = 2;
			_closure_mem(a, c + 0);
		}
		break;
	case 71: /* INDIRP */
		_label(LEFT_CHILD(a));
		if (	/* reg: INDIRP(VREGP) */
			LEFT_CHILD(a)->op == 615 /* VREGP */
		) {
			if (mayrecalc(a)) {
				struct _state *q = a->syms[RX]->u.t.cse->x.state;
				if (q->cost[_stmt_NT] == 0) {
					p->cost[_stmt_NT] = 0;
					p->rule._stmt = q->rule._stmt;
				}
				if (q->cost[_reg_NT] == 0) {
					p->cost[_reg_NT] = 0;
					p->rule._reg = q->rule._reg;
				}
				if (q->cost[_con_NT] == 0) {
					p->cost[_con_NT] = 0;
					p->rule._con = q->rule._con;
				}
				if (q->cost[_acon_NT] == 0) {
					p->cost[_acon_NT] = 0;
					p->rule._acon = q->rule._acon;
				}
				if (q->cost[_base_NT] == 0) {
					p->cost[_base_NT] = 0;
					p->rule._base = q->rule._base;
				}
				if (q->cost[_index_NT] == 0) {
					p->cost[_index_NT] = 0;
					p->rule._index = q->rule._index;
				}
				if (q->cost[_con1_NT] == 0) {
					p->cost[_con1_NT] = 0;
					p->rule._con1 = q->rule._con1;
				}
				if (q->cost[_con2_NT] == 0) {
					p->cost[_con2_NT] = 0;
					p->rule._con2 = q->rule._con2;
				}
				if (q->cost[_con3_NT] == 0) {
					p->cost[_con3_NT] = 0;
					p->rule._con3 = q->rule._con3;
				}
				if (q->cost[_addr_NT] == 0) {
					p->cost[_addr_NT] = 0;
					p->rule._addr = q->rule._addr;
				}
				if (q->cost[_mem_NT] == 0) {
					p->cost[_mem_NT] = 0;
					p->rule._mem = q->rule._mem;
				}
				if (q->cost[_rc_NT] == 0) {
					p->cost[_rc_NT] = 0;
					p->rule._rc = q->rule._rc;
				}
				if (q->cost[_mr_NT] == 0) {
					p->cost[_mr_NT] = 0;
					p->rule._mr = q->rule._mr;
				}
				if (q->cost[_mrc0_NT] == 0) {
					p->cost[_mrc0_NT] = 0;
					p->rule._mrc0 = q->rule._mrc0;
				}
				if (q->cost[_mrc1_NT] == 0) {
					p->cost[_mrc1_NT] = 0;
					p->rule._mrc1 = q->rule._mrc1;
				}
				if (q->cost[_mrc3_NT] == 0) {
					p->cost[_mrc3_NT] = 0;
					p->rule._mrc3 = q->rule._mrc3;
				}
				if (q->cost[_rc5_NT] == 0) {
					p->cost[_rc5_NT] = 0;
					p->rule._rc5 = q->rule._rc5;
				}
				if (q->cost[_memf_NT] == 0) {
					p->cost[_memf_NT] = 0;
					p->rule._memf = q->rule._memf;
				}
				if (q->cost[_flt_NT] == 0) {
					p->cost[_flt_NT] = 0;
					p->rule._flt = q->rule._flt;
				}
				if (q->cost[_addrj_NT] == 0) {
					p->cost[_addrj_NT] = 0;
					p->rule._addrj = q->rule._addrj;
				}
				if (q->cost[_cmpf_NT] == 0) {
					p->cost[_cmpf_NT] = 0;
					p->rule._cmpf = q->rule._cmpf;
				}
			}
			c = 0;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 5;
				_closure_reg(a, c + 0);
			}
		}
		/* mem: INDIRP(addr) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addr_NT] + 0;
		if (c + 0 < p->cost[_mem_NT]) {
			p->cost[_mem_NT] = c + 0;
			p->rule._mem = 3;
			_closure_mem(a, c + 0);
		}
		break;
	case 73: /* INDIRB */
		_label(LEFT_CHILD(a));
		break;
	case 85: /* CVCI */
		_label(LEFT_CHILD(a));
		if (	/* reg: CVCI(INDIRC(addr)) */
			LEFT_CHILD(a)->op == 67 /* INDIRC */
		) {
			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 44;
				_closure_reg(a, c + 0);
			}
		}
		/* reg: CVCI(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 48;
			_closure_reg(a, c + 0);
		}
		break;
	case 86: /* CVCU */
		_label(LEFT_CHILD(a));
		if (	/* reg: CVCU(INDIRC(addr)) */
			LEFT_CHILD(a)->op == 67 /* INDIRC */
		) {
			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 45;
				_closure_reg(a, c + 0);
			}
		}
		/* reg: CVCU(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 49;
			_closure_reg(a, c + 0);
		}
		break;
	case 97: /* CVDF */
		_label(LEFT_CHILD(a));
		/* reg: CVDF(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 12;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 68;
			_closure_reg(a, c + 0);
		}
		break;
	case 101: /* CVDI */
		_label(LEFT_CHILD(a));
		/* reg: CVDI(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 31;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 69;
			_closure_reg(a, c + 0);
		}
		break;
	case 114: /* CVFD */
		_label(LEFT_CHILD(a));
		if (	/* memf: CVFD(INDIRF(addr)) */
			LEFT_CHILD(a)->op == 65 /* INDIRF */
		) {
			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 0;
			if (c + 0 < p->cost[_memf_NT]) {
				p->cost[_memf_NT] = c + 0;
				p->rule._memf = 3;
				_closure_memf(a, c + 0);
			}
		}
		/* reg: CVFD(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 67;
			_closure_reg(a, c + 0);
		}
		break;
	case 130: /* CVID */
		_label(LEFT_CHILD(a));
		if (	/* reg: CVID(INDIRI(addr)) */
			LEFT_CHILD(a)->op == 69 /* INDIRI */
		) {
			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 10;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 70;
				_closure_reg(a, c + 0);
			}
		}
		/* reg: CVID(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 12;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 71;
			_closure_reg(a, c + 0);
		}
		break;
	case 131: /* CVIC */
		_label(LEFT_CHILD(a));
		/* reg: CVIC(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 52;
			_closure_reg(a, c + 0);
		}
		break;
	case 132: /* CVIS */
		_label(LEFT_CHILD(a));
		/* reg: CVIS(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 53;
			_closure_reg(a, c + 0);
		}
		break;
	case 134: /* CVIU */
		_label(LEFT_CHILD(a));
		/* reg: CVIU(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (notarget(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 7;
			_closure_reg(a, c + 0);
		}
		/* reg: CVIU(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 40;
			_closure_reg(a, c + 0);
		}
		break;
	case 150: /* CVPU */
		_label(LEFT_CHILD(a));
		/* reg: CVPU(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (notarget(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 8;
			_closure_reg(a, c + 0);
		}
		/* reg: CVPU(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 41;
			_closure_reg(a, c + 0);
		}
		break;
	case 165: /* CVSI */
		_label(LEFT_CHILD(a));
		if (	/* reg: CVSI(INDIRS(addr)) */
			LEFT_CHILD(a)->op == 68 /* INDIRS */
		) {
			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 46;
				_closure_reg(a, c + 0);
			}
		}
		/* reg: CVSI(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 50;
			_closure_reg(a, c + 0);
		}
		break;
	case 166: /* CVSU */
		_label(LEFT_CHILD(a));
		if (	/* reg: CVSU(INDIRS(addr)) */
			LEFT_CHILD(a)->op == 68 /* INDIRS */
		) {
			c = ((struct _state *)(LEFT_CHILD(LEFT_CHILD(a))->x.state))->cost[_addr_NT] + 3;
			if (c + 0 < p->cost[_reg_NT]) {
				p->cost[_reg_NT] = c + 0;
				p->rule._reg = 47;
				_closure_reg(a, c + 0);
			}
		}
		/* reg: CVSU(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 3;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 51;
			_closure_reg(a, c + 0);
		}
		break;
	case 179: /* CVUC */
		_label(LEFT_CHILD(a));
		/* reg: CVUC(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 54;
			_closure_reg(a, c + 0);
		}
		break;
	case 180: /* CVUS */
		_label(LEFT_CHILD(a));
		/* reg: CVUS(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 55;
			_closure_reg(a, c + 0);
		}
		break;
	case 181: /* CVUI */
		_label(LEFT_CHILD(a));
		/* reg: CVUI(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (notarget(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 9;
			_closure_reg(a, c + 0);
		}
		/* reg: CVUI(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 42;
			_closure_reg(a, c + 0);
		}
		break;
	case 183: /* CVUP */
		_label(LEFT_CHILD(a));
		/* reg: CVUP(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (notarget(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 10;
			_closure_reg(a, c + 0);
		}
		/* reg: CVUP(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 43;
			_closure_reg(a, c + 0);
		}
		break;
	case 193: /* NEGF */
		_label(LEFT_CHILD(a));
		/* reg: NEGF(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 58;
			_closure_reg(a, c + 0);
		}
		break;
	case 194: /* NEGD */
		_label(LEFT_CHILD(a));
		/* reg: NEGD(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 57;
			_closure_reg(a, c + 0);
		}
		break;
	case 197: /* NEGI */
		_label(LEFT_CHILD(a));
		/* reg: NEGI(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 28;
			_closure_reg(a, c + 0);
		}
		break;
	case 209: /* CALLF */
		_label(LEFT_CHILD(a));
		/* reg: CALLF(addrj) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 73;
			_closure_reg(a, c + 0);
		}
		break;
	case 210: /* CALLD */
		_label(LEFT_CHILD(a));
		/* reg: CALLD(addrj) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 74;
			_closure_reg(a, c + 0);
		}
		break;
	case 213: /* CALLI */
		_label(LEFT_CHILD(a));
		/* reg: CALLI(addrj) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 72;
			_closure_reg(a, c + 0);
		}
		break;
	case 216: /* CALLV */
		_label(LEFT_CHILD(a));
		/* stmt: CALLV(addrj) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 75;
		}
		break;
	case 217: /* CALLB */
		break;
	case 225: /* LOADF */
		break;
	case 226: /* LOADD */
		break;
	case 227: /* LOADC */
		_label(LEFT_CHILD(a));
		/* reg: LOADC(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 13;
			_closure_reg(a, c + 0);
		}
		break;
	case 228: /* LOADS */
		_label(LEFT_CHILD(a));
		/* reg: LOADS(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 16;
			_closure_reg(a, c + 0);
		}
		break;
	case 229: /* LOADI */
		_label(LEFT_CHILD(a));
		/* reg: LOADI(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 14;
			_closure_reg(a, c + 0);
		}
		break;
	case 230: /* LOADU */
		_label(LEFT_CHILD(a));
		/* reg: LOADU(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 17;
			_closure_reg(a, c + 0);
		}
		break;
	case 231: /* LOADP */
		_label(LEFT_CHILD(a));
		/* reg: LOADP(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + (move(a));
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 15;
			_closure_reg(a, c + 0);
		}
		break;
	case 233: /* LOADB */
		break;
	case 241: /* RETF */
		_label(LEFT_CHILD(a));
		/* stmt: RETF(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 77;
		}
		break;
	case 242: /* RETD */
		_label(LEFT_CHILD(a));
		/* stmt: RETD(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 78;
		}
		break;
	case 245: /* RETI */
		_label(LEFT_CHILD(a));
		/* stmt: RETI(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 76;
		}
		break;
	case 263: /* ADDRGP */
		/* acon: ADDRGP */
		if (0 + 0 < p->cost[_acon_NT]) {
			p->cost[_acon_NT] = 0 + 0;
			p->rule._acon = 1;
		}
		/* base: ADDRGP */
		if (0 + 0 < p->cost[_base_NT]) {
			p->cost[_base_NT] = 0 + 0;
			p->rule._base = 1;
			_closure_base(a, 0 + 0);
		}
		/* addrj: ADDRGP */
		if (0 + 0 < p->cost[_addrj_NT]) {
			p->cost[_addrj_NT] = 0 + 0;
			p->rule._addrj = 1;
		}
		break;
	case 279: /* ADDRFP */
		/* base: ADDRFP */
		if (0 + 0 < p->cost[_base_NT]) {
			p->cost[_base_NT] = 0 + 0;
			p->rule._base = 6;
			_closure_base(a, 0 + 0);
		}
		break;
	case 295: /* ADDRLP */
		/* base: ADDRLP */
		if (0 + 0 < p->cost[_base_NT]) {
			p->cost[_base_NT] = 0 + 0;
			p->rule._base = 7;
			_closure_base(a, 0 + 0);
		}
		break;
	case 305: /* ADDF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: ADDF(reg,flt) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 60;
			_closure_reg(a, c + 0);
		}
		break;
	case 306: /* ADDD */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: ADDD(reg,flt) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 59;
			_closure_reg(a, c + 0);
		}
		break;
	case 309: /* ADDI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* base: ADDI(reg,acon) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_acon_NT] + 0;
		if (c + 0 < p->cost[_base_NT]) {
			p->cost[_base_NT] = c + 0;
			p->rule._base = 3;
			_closure_base(a, c + 0);
		}
		/* addr: ADDI(index,base) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_base_NT] + 0;
		if (c + 0 < p->cost[_addr_NT]) {
			p->cost[_addr_NT] = c + 0;
			p->rule._addr = 2;
			_closure_addr(a, c + 0);
		}
		/* reg: ADDI(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 18;
			_closure_reg(a, c + 0);
		}
		break;
	case 310: /* ADDU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* base: ADDU(reg,acon) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_acon_NT] + 0;
		if (c + 0 < p->cost[_base_NT]) {
			p->cost[_base_NT] = c + 0;
			p->rule._base = 5;
			_closure_base(a, c + 0);
		}
		/* addr: ADDU(index,base) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_base_NT] + 0;
		if (c + 0 < p->cost[_addr_NT]) {
			p->cost[_addr_NT] = c + 0;
			p->rule._addr = 4;
			_closure_addr(a, c + 0);
		}
		/* reg: ADDU(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 20;
			_closure_reg(a, c + 0);
		}
		break;
	case 311: /* ADDP */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* base: ADDP(reg,acon) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_acon_NT] + 0;
		if (c + 0 < p->cost[_base_NT]) {
			p->cost[_base_NT] = c + 0;
			p->rule._base = 4;
			_closure_base(a, c + 0);
		}
		/* addr: ADDP(index,base) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_index_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_base_NT] + 0;
		if (c + 0 < p->cost[_addr_NT]) {
			p->cost[_addr_NT] = c + 0;
			p->rule._addr = 3;
			_closure_addr(a, c + 0);
		}
		/* reg: ADDP(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 19;
			_closure_reg(a, c + 0);
		}
		break;
	case 321: /* SUBF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: SUBF(reg,flt) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 66;
			_closure_reg(a, c + 0);
		}
		break;
	case 322: /* SUBD */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: SUBD(reg,flt) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 65;
			_closure_reg(a, c + 0);
		}
		break;
	case 325: /* SUBI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: SUBI(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 21;
			_closure_reg(a, c + 0);
		}
		break;
	case 326: /* SUBU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: SUBU(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 23;
			_closure_reg(a, c + 0);
		}
		break;
	case 327: /* SUBP */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: SUBP(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 22;
			_closure_reg(a, c + 0);
		}
		break;
	case 341: /* LSHI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* index: LSHI(reg,con1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con1_NT] + 0;
		if (c + 0 < p->cost[_index_NT]) {
			p->cost[_index_NT] = c + 0;
			p->rule._index = 2;
			_closure_index(a, c + 0);
		}
		/* index: LSHI(reg,con2) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con2_NT] + 0;
		if (c + 0 < p->cost[_index_NT]) {
			p->cost[_index_NT] = c + 0;
			p->rule._index = 3;
			_closure_index(a, c + 0);
		}
		/* index: LSHI(reg,con3) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con3_NT] + 0;
		if (c + 0 < p->cost[_index_NT]) {
			p->cost[_index_NT] = c + 0;
			p->rule._index = 4;
			_closure_index(a, c + 0);
		}
		/* reg: LSHI(reg,rc5) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc5_NT] + 2;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 29;
			_closure_reg(a, c + 0);
		}
		break;
	case 342: /* LSHU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* index: LSHU(reg,con1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con1_NT] + 0;
		if (c + 0 < p->cost[_index_NT]) {
			p->cost[_index_NT] = c + 0;
			p->rule._index = 5;
			_closure_index(a, c + 0);
		}
		/* index: LSHU(reg,con2) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con2_NT] + 0;
		if (c + 0 < p->cost[_index_NT]) {
			p->cost[_index_NT] = c + 0;
			p->rule._index = 6;
			_closure_index(a, c + 0);
		}
		/* index: LSHU(reg,con3) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_con3_NT] + 0;
		if (c + 0 < p->cost[_index_NT]) {
			p->cost[_index_NT] = c + 0;
			p->rule._index = 7;
			_closure_index(a, c + 0);
		}
		/* reg: LSHU(reg,rc5) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc5_NT] + 2;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 30;
			_closure_reg(a, c + 0);
		}
		break;
	case 357: /* MODI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: MODI(reg,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 39;
			_closure_reg(a, c + 0);
		}
		break;
	case 358: /* MODU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: MODU(reg,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 37;
			_closure_reg(a, c + 0);
		}
		break;
	case 373: /* RSHI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: RSHI(reg,rc5) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc5_NT] + 2;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 31;
			_closure_reg(a, c + 0);
		}
		break;
	case 374: /* RSHU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: RSHU(reg,rc5) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc5_NT] + 2;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 32;
			_closure_reg(a, c + 0);
		}
		break;
	case 390: /* BANDU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: BANDU(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 24;
			_closure_reg(a, c + 0);
		}
		break;
	case 406: /* BCOMU */
		_label(LEFT_CHILD(a));
		/* reg: BCOMU(reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + 2;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 27;
			_closure_reg(a, c + 0);
		}
		break;
	case 422: /* BORU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: BORU(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 25;
			_closure_reg(a, c + 0);
		}
		break;
	case 438: /* BXORU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: BXORU(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 1;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 26;
			_closure_reg(a, c + 0);
		}
		break;
	case 449: /* DIVF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: DIVF(reg,flt) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 62;
			_closure_reg(a, c + 0);
		}
		break;
	case 450: /* DIVD */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: DIVD(reg,flt) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 61;
			_closure_reg(a, c + 0);
		}
		break;
	case 453: /* DIVI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: DIVI(reg,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 38;
			_closure_reg(a, c + 0);
		}
		break;
	case 454: /* DIVU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: DIVU(reg,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 36;
			_closure_reg(a, c + 0);
		}
		break;
	case 465: /* MULF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: MULF(reg,flt) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 64;
			_closure_reg(a, c + 0);
		}
		break;
	case 466: /* MULD */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: MULD(reg,flt) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_flt_NT] + 0;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 63;
			_closure_reg(a, c + 0);
		}
		break;
	case 469: /* MULI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: MULI(reg,mrc3) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc3_NT] + 14;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 33;
			_closure_reg(a, c + 0);
		}
		/* reg: MULI(con,mr) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_con_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mr_NT] + 13;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 34;
			_closure_reg(a, c + 0);
		}
		break;
	case 470: /* MULU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* reg: MULU(reg,mr) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mr_NT] + 13;
		if (c + 0 < p->cost[_reg_NT]) {
			p->cost[_reg_NT] = c + 0;
			p->rule._reg = 35;
			_closure_reg(a, c + 0);
		}
		break;
	case 481: /* EQF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: EQF(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 69;
		}
		break;
	case 482: /* EQD */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: EQD(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 63;
		}
		break;
	case 485: /* EQI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: EQI(mem,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 43;
		}
		/* stmt: EQI(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 53;
		}
		break;
	case 497: /* GEF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: GEF(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 70;
		}
		break;
	case 498: /* GED */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: GED(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 64;
		}
		break;
	case 501: /* GEI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: GEI(mem,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 44;
		}
		/* stmt: GEI(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 54;
		}
		break;
	case 502: /* GEU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: GEU(mem,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 49;
		}
		/* stmt: GEU(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 59;
		}
		break;
	case 513: /* GTF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: GTF(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 71;
		}
		break;
	case 514: /* GTD */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: GTD(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 65;
		}
		break;
	case 517: /* GTI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: GTI(mem,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 45;
		}
		/* stmt: GTI(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 55;
		}
		break;
	case 518: /* GTU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: GTU(mem,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 50;
		}
		/* stmt: GTU(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 60;
		}
		break;
	case 529: /* LEF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: LEF(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 72;
		}
		break;
	case 530: /* LED */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: LED(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 66;
		}
		break;
	case 533: /* LEI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: LEI(mem,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 46;
		}
		/* stmt: LEI(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 56;
		}
		break;
	case 534: /* LEU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: LEU(mem,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 51;
		}
		/* stmt: LEU(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 61;
		}
		break;
	case 545: /* LTF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: LTF(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 73;
		}
		break;
	case 546: /* LTD */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: LTD(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 67;
		}
		break;
	case 549: /* LTI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: LTI(mem,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 47;
		}
		/* stmt: LTI(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 57;
		}
		break;
	case 550: /* LTU */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: LTU(mem,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 52;
		}
		/* stmt: LTU(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 62;
		}
		break;
	case 561: /* NEF */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: NEF(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 74;
		}
		break;
	case 562: /* NED */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: NED(cmpf,reg) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_cmpf_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_reg_NT] + 0;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 68;
		}
		break;
	case 565: /* NEI */
		_label(LEFT_CHILD(a));
		_label(RIGHT_CHILD(a));
		/* stmt: NEI(mem,rc) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_mem_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_rc_NT] + 5;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 48;
		}
		/* stmt: NEI(reg,mrc1) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_reg_NT] + ((struct _state *)(RIGHT_CHILD(a)->x.state))->cost[_mrc1_NT] + 4;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 58;
		}
		break;
	case 584: /* JUMPV */
		_label(LEFT_CHILD(a));
		/* stmt: JUMPV(addrj) */
		c = ((struct _state *)(LEFT_CHILD(a)->x.state))->cost[_addrj_NT] + 3;
		if (c + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = c + 0;
			p->rule._stmt = 41;
		}
		break;
	case 600: /* LABELV */
		/* stmt: LABELV */
		if (0 + 0 < p->cost[_stmt_NT]) {
			p->cost[_stmt_NT] = 0 + 0;
			p->rule._stmt = 42;
		}
		break;
	case 615: /* VREGP */
		break;
	default:
		fatal("_label", "Bad terminal %d\n", OP_LABEL(a));
	}
}

static void _kids(p, eruleno, kids) NODEPTR_TYPE p, kids[]; int eruleno; {
	if (!p)
		fatal("_kids", "Null tree\n", 0);
	if (!kids)
		fatal("_kids", "Null kids\n", 0);
	switch (eruleno) {
	case 169: /* stmt: LABELV */
	case 165: /* addrj: ADDRGP */
	case 105: /* rc5: CNSTI */
	case 41: /* con3: CNSTU */
	case 40: /* con3: CNSTI */
	case 39: /* con2: CNSTU */
	case 38: /* con2: CNSTI */
	case 37: /* con1: CNSTU */
	case 36: /* con1: CNSTI */
	case 31: /* base: ADDRLP */
	case 30: /* base: ADDRFP */
	case 25: /* base: ADDRGP */
	case 23: /* acon: ADDRGP */
	case 17: /* con: CNSTU */
	case 16: /* con: CNSTS */
	case 15: /* con: CNSTP */
	case 14: /* con: CNSTI */
	case 13: /* con: CNSTC */
	case 6: /* reg: INDIRS(VREGP) */
	case 5: /* reg: INDIRP(VREGP) */
	case 4: /* reg: INDIRI(VREGP) */
	case 3: /* reg: INDIRF(VREGP) */
	case 2: /* reg: INDIRD(VREGP) */
	case 1: /* reg: INDIRC(VREGP) */
		break;
	case 12: /* stmt: ASGNS(VREGP,reg) */
	case 11: /* stmt: ASGNP(VREGP,reg) */
	case 10: /* stmt: ASGNI(VREGP,reg) */
	case 9: /* stmt: ASGNF(VREGP,reg) */
	case 8: /* stmt: ASGND(VREGP,reg) */
	case 7: /* stmt: ASGNC(VREGP,reg) */
		kids[0] = RIGHT_CHILD(p);
		break;
	case 191: /* cmpf: reg */
	case 190: /* cmpf: memf */
	case 167: /* addrj: mem */
	case 166: /* addrj: reg */
	case 150: /* flt: reg */
	case 149: /* flt: memf */
	case 141: /* reg: memf */
	case 106: /* rc5: reg */
	case 65: /* reg: mrc0 */
	case 64: /* reg: addr */
	case 63: /* mrc3: rc */
	case 62: /* mrc3: mem */
	case 61: /* mrc1: rc */
	case 60: /* mrc1: mem */
	case 59: /* mrc0: rc */
	case 58: /* mrc0: mem */
	case 57: /* mr: mem */
	case 56: /* mr: reg */
	case 55: /* rc: con */
	case 54: /* rc: reg */
	case 49: /* addr: index */
	case 45: /* addr: base */
	case 32: /* index: reg */
	case 26: /* base: reg */
	case 24: /* acon: con */
	case 18: /* stmt: reg */
		kids[0] = p;
		break;
	case 210: /* stmt: RETD(reg) */
	case 209: /* stmt: RETF(reg) */
	case 208: /* stmt: RETI(reg) */
	case 207: /* reg: CALLD(addrj) */
	case 206: /* reg: CALLF(addrj) */
	case 205: /* stmt: CALLV(addrj) */
	case 204: /* reg: CALLI(addrj) */
	case 168: /* stmt: JUMPV(addrj) */
	case 164: /* reg: CVID(reg) */
	case 162: /* reg: CVDI(reg) */
	case 160: /* reg: CVDF(reg) */
	case 159: /* reg: CVFD(reg) */
	case 148: /* reg: NEGF(reg) */
	case 147: /* reg: NEGD(reg) */
	case 146: /* stmt: ARGF(reg) */
	case 145: /* stmt: ARGD(reg) */
	case 139: /* memf: INDIRF(addr) */
	case 138: /* memf: INDIRD(addr) */
	case 135: /* stmt: ARGP(mrc3) */
	case 134: /* stmt: ARGI(mrc3) */
	case 129: /* reg: CVUS(reg) */
	case 128: /* reg: CVUC(reg) */
	case 127: /* reg: CVIS(reg) */
	case 126: /* reg: CVIC(reg) */
	case 125: /* reg: CVSU(reg) */
	case 124: /* reg: CVSI(reg) */
	case 123: /* reg: CVCU(reg) */
	case 122: /* reg: CVCI(reg) */
	case 117: /* reg: CVUP(reg) */
	case 116: /* reg: CVUI(reg) */
	case 115: /* reg: CVPU(reg) */
	case 114: /* reg: CVIU(reg) */
	case 94: /* reg: NEGI(reg) */
	case 93: /* reg: BCOMU(reg) */
	case 70: /* reg: LOADU(reg) */
	case 69: /* reg: LOADS(reg) */
	case 68: /* reg: LOADP(reg) */
	case 67: /* reg: LOADI(reg) */
	case 66: /* reg: LOADC(reg) */
	case 53: /* mem: INDIRS(addr) */
	case 52: /* mem: INDIRP(addr) */
	case 51: /* mem: INDIRI(addr) */
	case 50: /* mem: INDIRC(addr) */
	case 22: /* reg: CVUP(reg) */
	case 21: /* reg: CVUI(reg) */
	case 20: /* reg: CVPU(reg) */
	case 19: /* reg: CVIU(reg) */
		kids[0] = LEFT_CHILD(p);
		break;
	case 203: /* stmt: NEF(cmpf,reg) */
	case 202: /* stmt: LTF(cmpf,reg) */
	case 201: /* stmt: LEF(cmpf,reg) */
	case 200: /* stmt: GTF(cmpf,reg) */
	case 199: /* stmt: GEF(cmpf,reg) */
	case 198: /* stmt: EQF(cmpf,reg) */
	case 197: /* stmt: NED(cmpf,reg) */
	case 196: /* stmt: LTD(cmpf,reg) */
	case 195: /* stmt: LED(cmpf,reg) */
	case 194: /* stmt: GTD(cmpf,reg) */
	case 193: /* stmt: GED(cmpf,reg) */
	case 192: /* stmt: EQD(cmpf,reg) */
	case 189: /* stmt: LTU(reg,mrc1) */
	case 188: /* stmt: LEU(reg,mrc1) */
	case 187: /* stmt: GTU(reg,mrc1) */
	case 186: /* stmt: GEU(reg,mrc1) */
	case 185: /* stmt: NEI(reg,mrc1) */
	case 184: /* stmt: LTI(reg,mrc1) */
	case 183: /* stmt: LEI(reg,mrc1) */
	case 182: /* stmt: GTI(reg,mrc1) */
	case 181: /* stmt: GEI(reg,mrc1) */
	case 180: /* stmt: EQI(reg,mrc1) */
	case 179: /* stmt: LTU(mem,rc) */
	case 178: /* stmt: LEU(mem,rc) */
	case 177: /* stmt: GTU(mem,rc) */
	case 176: /* stmt: GEU(mem,rc) */
	case 175: /* stmt: NEI(mem,rc) */
	case 174: /* stmt: LTI(mem,rc) */
	case 173: /* stmt: LEI(mem,rc) */
	case 172: /* stmt: GTI(mem,rc) */
	case 171: /* stmt: GEI(mem,rc) */
	case 170: /* stmt: EQI(mem,rc) */
	case 158: /* reg: SUBF(reg,flt) */
	case 157: /* reg: SUBD(reg,flt) */
	case 156: /* reg: MULF(reg,flt) */
	case 155: /* reg: MULD(reg,flt) */
	case 154: /* reg: DIVF(reg,flt) */
	case 153: /* reg: DIVD(reg,flt) */
	case 152: /* reg: ADDF(reg,flt) */
	case 151: /* reg: ADDD(reg,flt) */
	case 143: /* stmt: ASGNF(addr,reg) */
	case 142: /* stmt: ASGND(addr,reg) */
	case 133: /* stmt: ASGNS(addr,rc) */
	case 132: /* stmt: ASGNP(addr,rc) */
	case 131: /* stmt: ASGNI(addr,rc) */
	case 130: /* stmt: ASGNC(addr,rc) */
	case 113: /* reg: MODI(reg,reg) */
	case 112: /* reg: DIVI(reg,reg) */
	case 111: /* reg: MODU(reg,reg) */
	case 110: /* reg: DIVU(reg,reg) */
	case 109: /* reg: MULU(reg,mr) */
	case 108: /* reg: MULI(con,mr) */
	case 107: /* reg: MULI(reg,mrc3) */
	case 100: /* reg: RSHU(reg,rc5) */
	case 99: /* reg: RSHI(reg,rc5) */
	case 98: /* reg: LSHU(reg,rc5) */
	case 97: /* reg: LSHI(reg,rc5) */
	case 79: /* reg: BXORU(reg,mrc1) */
	case 78: /* reg: BORU(reg,mrc1) */
	case 77: /* reg: BANDU(reg,mrc1) */
	case 76: /* reg: SUBU(reg,mrc1) */
	case 75: /* reg: SUBP(reg,mrc1) */
	case 74: /* reg: SUBI(reg,mrc1) */
	case 73: /* reg: ADDU(reg,mrc1) */
	case 72: /* reg: ADDP(reg,mrc1) */
	case 71: /* reg: ADDI(reg,mrc1) */
	case 48: /* addr: ADDU(index,base) */
	case 47: /* addr: ADDP(index,base) */
	case 46: /* addr: ADDI(index,base) */
	case 44: /* index: LSHU(reg,con3) */
	case 43: /* index: LSHU(reg,con2) */
	case 42: /* index: LSHU(reg,con1) */
	case 35: /* index: LSHI(reg,con3) */
	case 34: /* index: LSHI(reg,con2) */
	case 33: /* index: LSHI(reg,con1) */
	case 29: /* base: ADDU(reg,acon) */
	case 28: /* base: ADDP(reg,acon) */
	case 27: /* base: ADDI(reg,acon) */
		kids[0] = LEFT_CHILD(p);
		kids[1] = RIGHT_CHILD(p);
		break;
	case 104: /* stmt: ASGNI(addr,RSHU(mem,rc5)) */
	case 103: /* stmt: ASGNI(addr,RSHI(mem,rc5)) */
	case 102: /* stmt: ASGNI(addr,LSHU(mem,rc5)) */
	case 101: /* stmt: ASGNI(addr,LSHI(mem,rc5)) */
	case 92: /* stmt: ASGNI(addr,BXORU(mem,rc)) */
	case 91: /* stmt: ASGNI(addr,BORU(mem,rc)) */
	case 90: /* stmt: ASGNI(addr,BANDU(mem,rc)) */
	case 89: /* stmt: ASGNI(addr,SUBU(mem,rc)) */
	case 88: /* stmt: ASGNI(addr,SUBI(mem,rc)) */
	case 87: /* stmt: ASGNI(addr,ADDU(mem,rc)) */
	case 86: /* stmt: ASGNI(addr,ADDI(mem,rc)) */
	case 85: /* stmt: ASGNP(addr,SUBP(mem,con1)) */
	case 84: /* stmt: ASGNI(addr,SUBU(mem,con1)) */
	case 83: /* stmt: ASGNI(addr,SUBI(mem,con1)) */
	case 82: /* stmt: ASGNP(addr,ADDP(mem,con1)) */
	case 81: /* stmt: ASGNI(addr,ADDU(mem,con1)) */
	case 80: /* stmt: ASGNI(addr,ADDI(mem,con1)) */
		kids[0] = LEFT_CHILD(p);
		kids[1] = LEFT_CHILD(RIGHT_CHILD(p));
		kids[2] = RIGHT_CHILD(RIGHT_CHILD(p));
		break;
	case 161: /* stmt: ASGNI(addr,CVDI(reg)) */
	case 144: /* stmt: ASGNF(addr,CVDF(reg)) */
	case 136: /* stmt: ASGNB(reg,INDIRB(reg)) */
	case 96: /* stmt: ASGNI(addr,NEGI(mem)) */
	case 95: /* stmt: ASGNI(addr,BCOMU(mem)) */
		kids[0] = LEFT_CHILD(p);
		kids[1] = LEFT_CHILD(RIGHT_CHILD(p));
		break;
	case 163: /* reg: CVID(INDIRI(addr)) */
	case 140: /* memf: CVFD(INDIRF(addr)) */
	case 137: /* stmt: ARGB(INDIRB(reg)) */
	case 121: /* reg: CVSU(INDIRS(addr)) */
	case 120: /* reg: CVSI(INDIRS(addr)) */
	case 119: /* reg: CVCU(INDIRC(addr)) */
	case 118: /* reg: CVCI(INDIRC(addr)) */
		kids[0] = LEFT_CHILD(LEFT_CHILD(p));
		break;
	default:
		fatal("_kids", "Bad rule number %d\n", eruleno);
	}
}

static void progbeg(argc, argv) int argc; char *argv[]; {
	int i;

	{
		union {
			char c;
			int i;
		} u;
		u.i = 0;
		u.c = 1;
		swap = ((int)(u.i == 1)) != ((int)IR->little_endian);
	}
	parseflags(argc, argv);
	intreg[EAX] = mkreg("eax", EAX, 1, IREG);
	intreg[EDX] = mkreg("edx", EDX, 1, IREG);
	intreg[ECX] = mkreg("ecx", ECX, 1, IREG);
	intreg[EBX] = mkreg("ebx", EBX, 1, IREG);
	intreg[ESI] = mkreg("esi", ESI, 1, IREG);
	intreg[EDI] = mkreg("edi", EDI, 1, IREG);
	shortreg[EAX] = mkreg("ax", EAX, 1, IREG);
	shortreg[ECX] = mkreg("cx", ECX, 1, IREG);
	shortreg[EDX] = mkreg("dx", EDX, 1, IREG);
	shortreg[EBX] = mkreg("bx", EBX, 1, IREG);
	shortreg[ESI] = mkreg("si", ESI, 1, IREG);
	shortreg[EDI] = mkreg("di", EDI, 1, IREG);

	charreg[EAX]  = mkreg("al", EAX, 1, IREG);
	charreg[ECX]  = mkreg("cl", ECX, 1, IREG);
	charreg[EDX]  = mkreg("dl", EDX, 1, IREG);
	charreg[EBX]  = mkreg("bl", EBX, 1, IREG);
	for (i = 0; i < 8; i++)
		fltreg[i] = mkreg("%d", i, 0, FREG);
	rmap[C] = mkwildcard(charreg);
	rmap[S] = mkwildcard(shortreg);
	rmap[P] = rmap[B] = rmap[U] = rmap[I] = mkwildcard(intreg);
	rmap[F] = rmap[D] = mkwildcard(fltreg);
	tmask[IREG] = (1<<EDI) | (1<<ESI) | (1<<EBX)
	            | (1<<EDX) | (1<<ECX) | (1<<EAX);
	vmask[IREG] = 0;
	tmask[FREG] = 0xff;
	vmask[FREG] = 0;
	print(".486\n");
	print(".model small\n");
	print("extrn __turboFloat:near\n");
	print("extrn __setargv:near\n");
	cseg = 0;
	quo = mkreg("eax", EAX, 1, IREG);
	quo->x.regnode->mask |= 1<<EDX;
	rem = mkreg("edx", EDX, 1, IREG);
	rem->x.regnode->mask |= 1<<EAX;
}
static void segment(n) int n; {
	if (n == cseg)
		return;
	if (cseg == CODE)
		print("_TEXT ends\n");
	else if (cseg == DATA || cseg == BSS || cseg == LIT)
		print("_DATA ends\n");
	cseg = n;
	if (cseg == CODE)
		print("_TEXT segment\n");
	else if (cseg == DATA || cseg == BSS || cseg == LIT)
		print("_DATA segment\n");
}
static void progend() {
	segment(0);
	print("end\n");
}
static void target(p) Node p; {
	assert(p);
	switch (p->op) {
	case RSHI: case RSHU: case LSHI: case LSHU:
		if (generic(p->kids[1]->op) != CNST
		&& !(   generic(p->kids[1]->op) == INDIR
		     && p->kids[1]->kids[0]->op == VREG+P
		     && p->kids[1]->syms[RX]->u.t.cse
		     && generic(p->kids[1]->syms[RX]->u.t.cse->op) == CNST
)) {
			rtarget(p, 1, intreg[ECX]);
			setreg(p, intreg[EAX]);
		}
		break;
	case MULU:
		setreg(p, quo);
		rtarget(p, 0, intreg[EAX]);
		break;
	case DIVI: case DIVU:
		setreg(p, quo);
		rtarget(p, 0, intreg[EAX]);
		rtarget(p, 1, intreg[ECX]);
		break;
	case MODI: case MODU:
		setreg(p, rem);
		rtarget(p, 0, intreg[EAX]);
		rtarget(p, 1, intreg[ECX]);
		break;
	case ASGNB:
		rtarget(p, 0, intreg[EDI]);
		rtarget(p->kids[1], 0, intreg[ESI]);
		break;
	case ARGB:
		rtarget(p->kids[0], 0, intreg[ESI]);
		break;
	case CALLI: case CALLV:
		setreg(p, intreg[EAX]);
		break;
	case RETI:
		rtarget(p, 0, intreg[EAX]);
		break;
	}
}

static void clobber(p) Node p; {
	static int nstack = 0;

	assert(p);
	nstack = ckstack(p, nstack);
	switch (p->op) {
	case ASGNB: case ARGB:
		spill(1<<ECX | 1<<ESI | 1<<EDI, IREG, p);
		break;
	case EQD: case LED: case GED: case LTD: case GTD: case NED:
	case EQF: case LEF: case GEF: case LTF: case GTF: case NEF:
		spill(1<<EAX, IREG, p);
		break;
	case CALLD: case CALLF:
		spill(1<<EDX | 1<<EAX, IREG, p);
		break;
	}
}
#define isfp(p) (optype((p)->op)==F || optype((p)->op)==D)

static int ckstack(p, n) Node p; int n; {
	int i;

	for (i = 0; i < NELEMS(p->x.kids) && p->x.kids[i]; i++)
		if (isfp(p->x.kids[i]))
			n--;
	if (isfp(p) && p->count > 0)
		n++;
	if (n > 8)
		error("expression too complicated\n");
	debug(fprint(2, "(ckstack(%x)=%d)\n", p, n));
	assert(n >= 0);
	return n;
}
static int memop(p) Node p; {
	assert(p);
	assert(generic(p->op) == ASGN);
	assert(p->kids[0]);
	assert(p->kids[1]);
	if (generic(p->kids[1]->kids[0]->op) == INDIR
	&& sametree(p->kids[0], p->kids[1]->kids[0]->kids[0]))
		return 3;
	else
		return LBURG_MAX;
}
static int sametree(p, q) Node p, q; {
	return p == NULL && q == NULL
	|| p && q && p->op == q->op && p->syms[0] == q->syms[0]
		&& sametree(p->kids[0], q->kids[0])
		&& sametree(p->kids[1], q->kids[1]);
}
static void emit2(p) Node p; {
#define preg(f) ((f)[getregnum(p->x.kids[0])]->x.name)

	if (p->op == CVCI)
		print("movsx %s,%s\n", p->syms[RX]->x.name
, preg(charreg));
	else if (p->op == CVCU)
		print("movzx %s,%s\n", p->syms[RX]->x.name
, preg(charreg));
	else if (p->op == CVSI)
		print("movsx %s,%s\n", p->syms[RX]->x.name
, preg(shortreg));
	else if (p->op == CVSU)
		print("movzx %s,%s\n", p->syms[RX]->x.name
, preg(shortreg));
	else if (p->op == CVIC || p->op == CVIS
	      || p->op == CVUC || p->op == CVUS) {
		char *dst = shortreg[getregnum(p)]->x.name;
		char *src = preg(shortreg);
		if (dst != src)
			print("mov %s,%s\n", dst, src);
	}
}

static void doarg(p) Node p; {
	assert(p && p->syms[0]);
	mkactual(4, p->syms[0]->u.c.v.i);
}
static void blkfetch(k, off, reg, tmp)
int k, off, reg, tmp; {}
static void blkstore(k, off, reg, tmp)
int k, off, reg, tmp; {}
static void blkloop(dreg, doff, sreg, soff, size, tmps)
int dreg, doff, sreg, soff, size, tmps[]; {}
static void local(p) Symbol p; {
	if (isfloat(p->type))
		p->sclass = AUTO;
	if (askregvar(p, rmap[ttob(p->type)]) == 0)
		mkauto(p);
}
static void function(f, caller, callee, n)
Symbol f, callee[], caller[]; int n; {
	int i;

	print("%s:\n", f->x.name);
	print("push ebx\n");
	print("push esi\n");
	print("push edi\n");
	print("push ebp\n");
	print("mov ebp,esp\n");
usedmask[0] = usedmask[1] = 0;
freemask[0] = freemask[1] = ~(unsigned)0;
	offset = 16 + 4;
	for (i = 0; callee[i]; i++) {
		Symbol p = callee[i];
		Symbol q = caller[i];
		assert(q);
		p->x.offset = q->x.offset = offset;
		p->x.name = q->x.name = stringf("%d", p->x.offset);
		p->sclass = q->sclass = AUTO;
		offset += roundup(q->type->size, 4);
	}
	assert(caller[i] == 0);
	offset = maxoffset = 0;
	gencode(caller, callee);
	framesize = roundup(maxoffset, 4);
	if (framesize > 0)
		print("sub esp,%d\n", framesize);
	emitcode();
	print("mov esp,ebp\n");
	print("pop ebp\n");
	print("pop edi\n");
	print("pop esi\n");
	print("pop ebx\n");
	print("ret\n");
}
static void defsymbol(p) Symbol p; {
	if (p->scope >= LOCAL && p->sclass == STATIC)
		p->x.name = stringf("L%d", genlabel(1));
	else if (p->generated)
		p->x.name = stringf("L%s", p->name);
	else if (p->scope == GLOBAL || p->sclass == EXTERN)
		p->x.name = stringf("_%s", p->name);
	else if (p->scope == CONSTANTS
	&& (isint(p->type) || isptr(p->type))
	&& p->name[0] == '0' && p->name[1] == 'x')
		p->x.name = stringf("0%sH", &p->name[2]);
	else
		p->x.name = p->name;
}
static void address(q, p, n) Symbol q, p; int n; {
	if (p->scope == GLOBAL
	|| p->sclass == STATIC || p->sclass == EXTERN)
		q->x.name = stringf("%s%s%d",
			p->x.name, n >= 0 ? "+" : "", n);
	else {
		q->x.offset = p->x.offset + n;
		q->x.name = stringd(q->x.offset);
	}
}
static void defconst(ty, v) int ty; Value v; {
	switch (ty) {
		case C: print("db %d\n",   v.uc); return;
		case S: print("dw %d\n",   v.ss); return;
		case I: print("dd %d\n",   v.i ); return;
		case U: print("dd 0%xH\n", v.u ); return;
		case P: print("dd 0%xH\n", v.p ); return;
		case F:
			print("dd 0%xH\n", *(unsigned *)&v.f);
			return;
		case D: {
			unsigned *p = (unsigned *)&v.d;
			print("dd 0%xH,0%xH\n", p[swap], p[1 - swap]);
			return;
			}
	}
	assert(0);
}
static void defaddress(p) Symbol p; {
	print("dd %s\n", p->x.name);
}
static void defstring(n, str) int n; char *str; {
	char *s;

	for (s = str; s < str + n; s++)
		print("db %d\n", (*s)&0377);
}
static void export(p) Symbol p; {
	print("public %s\n", p->x.name);
}
static void import(p) Symbol p; {
	int oldseg = cseg;

	if (p->ref > 0) {
		segment(0);
		print("extrn %s:near\n", p->x.name);
		segment(oldseg);
	}
}
static void global(p) Symbol p; {
	print("align %d\n",
		p->type->align > 4 ? 4 : p->type->align);
	print("%s label byte\n", p->x.name);
	if (p->u.seg == BSS)
		print("db %d dup (0)\n", p->type->size);
}
static void space(n) int n; {
	if (cseg != BSS)
		print("db %d dup (0)\n", n);
}
Interface x86IR = {
	1, 1, 0,  /* char */
	2, 2, 0,  /* short */
	4, 4, 0,  /* int */
	4, 4, 1,  /* float */
	8, 4, 1,  /* double */
	4, 4, 0,  /* T * */
	0, 4, 0,  /* struct; so that ARGB keeps stack aligned */
	1,        /* little_endian */
	0,        /* mulops_calls */
	0,        /* wants_callb */
	1,        /* wants_argb */
	0,        /* left_to_right */
	0,        /* wants_dag */
	address,
	blockbeg,
	blockend,
	defaddress,
	defconst,
	defstring,
	defsymbol,
	emit,
	export,
	function,
	gen,
	global,
	import,
	local,
	progbeg,
	progend,
	segment,
	space,
	0, 0, 0, 0, 0, 0, 0,
	{1, blkfetch, blkstore, blkloop,
	    _label,
	    _rule,
	    _nts,
	    _kids,
	    _opname,
	    _arity,
	    _string,
	    _templates,
	    _isinstruction,
	    _ntname,
	    emit2,
	    doarg,
	    target,
	    clobber,
}
};
